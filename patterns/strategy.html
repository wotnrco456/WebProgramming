<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategy 패턴 - GameDev PatternHub</title>
    <link rel="stylesheet" href="../css/common.css">
    <link rel="stylesheet" href="../css/layout.css">
    <link rel="stylesheet" href="../css/pattern-detail.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js"></script>
</head>
<body>
    <header class="header">
        <nav class="nav-container">
            <div class="logo">
                <h1>GameDev PatternHub</h1>
            </div>
            <div class="nav-links">
                <a href="../index.html">홈</a>
                <a href="../patterns.html">패턴 목록</a>
                <a href="#">데모 게임</a>
                <a href="#">문서</a>
            </div>
            <button class="mobile-menu-btn">
                <i class="fas fa-bars"></i>
            </button>
        </nav>
    </header>

    <main class="pattern-detail">
        <section class="pattern-header">
            <div class="container">
                <h1>Strategy 패턴</h1>
                <div class="pattern-meta">
                    <span class="category">행동 패턴</span>
                    <span class="difficulty">난이도: ★★★☆☆</span>
                </div>
            </div>
        </section>

        <section class="pattern-content">
            <div class="container">
                <div class="content-section">
                    <h2>패턴 개요</h2>
                    <p>Strategy 패턴은 알고리즘 군을 정의하고, 각각을 캡슐화하여 상호 교환 가능하게 만드는 디자인 패턴입니다. 이 패턴을 사용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있으며, 런타임에 알고리즘을 교체할 수 있습니다.</p>
                    
                    <div class="pattern-benefits">
                        <h3>주요 장점</h3>
                        <ul>
                            <li>알고리즘을 쉽게 교체할 수 있는 유연성 제공</li>
                            <li>조건문을 줄여 코드 가독성 향상</li>
                            <li>새로운 전략 추가가 용이하여 확장성이 높음</li>
                            <li>각 알고리즘을 캡슐화하여 재사용성 증가</li>
                            <li>책임의 분리를 통한 유지보수성 향상</li>
                        </ul>
                    </div>

                    <div class="pattern-use-cases">
                        <h3>사용 사례</h3>
                        <ul>
                            <li>게임 캐릭터의 다양한 공격 방식 구현</li>
                            <li>AI 행동 패턴 정의 및 전환</li>
                            <li>게임 난이도에 따른 다양한 동작 방식 구현</li>
                            <li>이동, 점프, 회피 등 다양한 캐릭터 능력 구현</li>
                            <li>경로 탐색이나 의사 결정 알고리즘 전환</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>1. Strategy 패턴의 기본 개념</h2>
                    <div class="pattern-pros-cons">
                        <h3>1.1 패턴 구성 요소</h3>
                        <ul>
                            <li><strong>Strategy (전략) 인터페이스</strong>: 모든 구체적인 전략이 구현해야 하는 공통 인터페이스를 정의합니다.</li>
                            <li><strong>ConcreteStrategy (구체적인 전략)</strong>: Strategy 인터페이스를 구현하는 다양한 알고리즘 클래스들입니다.</li>
                            <li><strong>Context (컨텍스트)</strong>: Strategy 객체를 참조하고 사용하는 클래스입니다. 런타임에 다른 전략으로 교체할 수 있는 메서드를 제공합니다.</li>
                        </ul>
                        
                        <h3>1.2 패턴 작동 방식</h3>
                        <p>컨텍스트 객체는 전략 객체의 레퍼런스를 유지하며, 실제 작업을 처리할 때 해당 전략 객체에게 작업을 위임합니다. 클라이언트는 원하는 전략을 선택하고 컨텍스트에 설정할 수 있으며, 런타임에 전략을 변경할 수 있습니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>2. 왜 Strategy 패턴을 사용해야 하는가?</h2>
                    <div class="pattern-benefits">
                        <h3>2.1 유연한 알고리즘 교체</h3>
                        <p>조건문이나 상속 대신 전략 객체를 교체하는 방식으로 런타임에 동작을 변경할 수 있어 코드의 유연성이 향상됩니다.</p>
                        
                        <h3>2.2 조건문 제거</h3>
                        <p>여러 조건에 따라 다른 알고리즘을 사용하는 복잡한 조건문을 제거하고, 각 알고리즘을 개별 클래스로 캡슐화하여 코드의 명확성이 높아집니다.</p>
                        
                        <h3>2.3 Open/Closed 원칙 준수</h3>
                        <p>새로운 전략을 추가할 때 기존 코드를 수정하지 않고도 확장할 수 있어 Open/Closed 원칙을 준수합니다.</p>
                        
                        <h3>2.4 재사용성 향상</h3>
                        <p>각 알고리즘이 독립적인 클래스로 캡슐화되어 있어 다른 컨텍스트에서도 재사용이 가능합니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>3. 어떤 상황에서 사용해야 하는가?</h2>
                    <div class="pattern-use-cases">
                        <h3>3.1 다양한 알고리즘 변형이 필요한 경우</h3>
                        <p>게임에서 AI 캐릭터의 다양한 행동 패턴, 다른 타입의 무기, 다양한 이동 방식 등 여러 알고리즘 변형이 필요할 때 적합합니다.</p>
                        
                        <h3>3.2 런타임에 동작 교체가 필요한 경우</h3>
                        <p>게임 진행 중 캐릭터의 능력이 변하거나, 상황에 따라 다른 전략을 사용해야 할 때 유용합니다.</p>
                        
                        <h3>3.3 조건문이 복잡해지는 경우</h3>
                        <p>동작 방식을 결정하는 조건문이 너무 복잡해질 때, 전략 패턴을 사용하여 각 동작을 개별 클래스로 분리하면 코드가 간결해집니다.</p>
                        
                        <h3>3.4 클래스 상속으로 인한 문제가 발생할 경우</h3>
                        <p>상속을 통해 여러 알고리즘을 처리하려고 할 때 클래스 계층 구조가 복잡해지는 경우, 전략 패턴을 사용하여 구성(Composition)으로 문제를 해결할 수 있습니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>4. 어떻게 구현하는가?</h2>
                    <div class="code-tabs">
                        <div class="tab-buttons">
                            <button class="tab-btn active" data-lang="csharp">C#</button>
                            <button class="tab-btn" data-lang="cpp">C++</button>
                        </div>
                        
                        <div class="tab-content">
                            <div class="code-block active" id="csharp-code">
                                <h3>4.1 Strategy 인터페이스 정의</h3>
                                <pre><code class="language-csharp">using System;

namespace StrategyPattern
{
    // Strategy 인터페이스 - 모든 전략이 구현해야 하는 메서드 정의
    public interface IAbilityStrategy
    {
        // 능력 사용 시 그 효과를 정의하는 메서드
        void Execute(AbilityContext context);
        string Name { get; }
    }
    
    // Context 클래스 - 전략 객체를 사용하는 컨텍스트
    public class AbilityContext
    {
        // 현재 전략 참조
        private IAbilityStrategy _currentStrategy;
        
        // 컨텍스트 데이터
        public string PlayerName { get; set; }
        public int PlayerLevel { get; set; }
        public int HealthPoints { get; set; }
        
        public AbilityContext(string playerName, int playerLevel, int healthPoints)
        {
            PlayerName = playerName;
            PlayerLevel = playerLevel;
            HealthPoints = healthPoints;
        }
        
        // 전략 설정 메서드
        public void SetStrategy(IAbilityStrategy strategy)
        {
            _currentStrategy = strategy;
            Console.WriteLine($"전략이 '{strategy.Name}'로 설정되었습니다.");
        }
        
        // 전략 실행 메서드
        public void ExecuteStrategy()
        {
            if (_currentStrategy == null)
            {
                Console.WriteLine("전략이 설정되지 않았습니다.");
                return;
            }
            
            // 전략에게 실행 위임
            _currentStrategy.Execute(this);
        }
    }
}</code></pre>

                                <h3>4.2 ConcreteStrategy 구현</h3>
                                <pre><code class="language-csharp">using System;

namespace StrategyPattern
{
    // 구체적인 전략 1 - 치유 능력
    public class HealingAbility : IAbilityStrategy
    {
        private readonly int _healingAmount;
        
        public string Name => "치유 능력";
        
        public HealingAbility(int healingAmount)
        {
            _healingAmount = healingAmount;
        }
        
        public void Execute(AbilityContext context)
        {
            // 치유 로직 구현
            int oldHealth = context.HealthPoints;
            context.HealthPoints += _healingAmount;
            
            Console.WriteLine($"{context.PlayerName}이(가) {Name}을 사용했습니다!");
            Console.WriteLine($"체력이 {oldHealth}에서 {context.HealthPoints}로 회복되었습니다.");
        }
    }
    
    // 구체적인 전략 2 - 방어 능력
    public class DefenseAbility : IAbilityStrategy
    {
        private readonly int _defenseDuration;
        
        public string Name => "방어 능력";
        
        public DefenseAbility(int defenseDuration)
        {
            _defenseDuration = defenseDuration;
        }
        
        public void Execute(AbilityContext context)
        {
            // 방어 로직 구현
            Console.WriteLine($"{context.PlayerName}이(가) {Name}을 사용했습니다!");
            Console.WriteLine($"{_defenseDuration}초 동안 모든 데미지가 50% 감소합니다.");
        }
    }
    
    // 구체적인 전략 3 - 공격 능력
    public class AttackAbility : IAbilityStrategy
    {
        private readonly int _attackPower;
        
        public string Name => "공격 능력";
        
        public AttackAbility(int attackPower)
        {
            _attackPower = attackPower;
        }
        
        public void Execute(AbilityContext context)
        {
            // 공격 로직 구현
            int bonusDamage = context.PlayerLevel * 5;
            int totalDamage = _attackPower + bonusDamage;
            
            Console.WriteLine($"{context.PlayerName}이(가) {Name}을 사용했습니다!");
            Console.WriteLine($"모든 적에게 {totalDamage}(기본: {_attackPower}, 보너스: {bonusDamage}) 데미지를 입혔습니다.");
        }
    }
}</code></pre>

                                <h3>4.3 Strategy 패턴 확장</h3>
                                <pre><code class="language-csharp">using System;

namespace StrategyPattern
{
    // 능력 특성을 나타내는 열거형
    [Flags]
    public enum AbilityAttributes
    {
        None = 0,
        Fire = 1,
        Ice = 2,
        Lightning = 4,
        Earth = 8,
        Healing = 16,
        Buff = 32,
        Debuff = 64
    }
    
    // 확장된 Strategy 인터페이스
    public interface IEnhancedAbilityStrategy : IAbilityStrategy
    {
        AbilityAttributes Attributes { get; }
        int Cooldown { get; }
        int ManaCost { get; }
        string Description { get; }
    }
    
    // Decorator 패턴을 활용한 Enhanced 능력 구현
    public class EnhancedAbility : IEnhancedAbilityStrategy
    {
        private readonly IAbilityStrategy _baseAbility;
        private readonly AbilityAttributes _attributes;
        private readonly int _cooldown;
        private readonly int _manaCost;
        private readonly string _description;
        
        public string Name => _baseAbility.Name;
        public AbilityAttributes Attributes => _attributes;
        public int Cooldown => _cooldown;
        public int ManaCost => _manaCost;
        public string Description => _description;
        
        public EnhancedAbility(IAbilityStrategy baseAbility, AbilityAttributes attributes, 
                            int cooldown, int manaCost, string description)
        {
            _baseAbility = baseAbility;
            _attributes = attributes;
            _cooldown = cooldown;
            _manaCost = manaCost;
            _description = description;
        }
        
        public void Execute(AbilityContext context)
        {
            // 기본 능력 실행
            _baseAbility.Execute(context);
            
            // 특성에 따른 추가 효과
            if ((_attributes & AbilityAttributes.Fire) != 0)
            {
                Console.WriteLine("불 속성 효과: 목표에게 화상 데미지를 추가로 입힙니다.");
            }
            
            if ((_attributes & AbilityAttributes.Healing) != 0)
            {
                Console.WriteLine("치유 속성 효과: 시간에 따라 추가 체력을 회복합니다.");
            }
            
            // 마나 소모 과정 시뮬레이션
            Console.WriteLine($"마나 {_manaCost} 소모, 쿨다운 {_cooldown}초 적용.");
        }
    }
}</code></pre>

                                <h3>4.4 사용 예시</h3>
                                <pre><code class="language-csharp">using System;

namespace StrategyPattern
{
    public class Program
    {
        public static void Main(string[] args)
        {
            Console.WriteLine("플레이어 캩0릭터 생성...");
            var context = new AbilityContext("Player1", 10, 100);
            
            Console.WriteLine("\n==== 기본 능력 사용 테스트 ====\n");
            
            // 치유 능력 전략 생성 및 사용
            var healingAbility = new HealingAbility(30);
            context.SetStrategy(healingAbility);
            context.ExecuteStrategy();
            
            Console.WriteLine();
            
            // 방어 능력 전략 생성 및 사용
            var defenseAbility = new DefenseAbility(5);
            context.SetStrategy(defenseAbility);
            context.ExecuteStrategy();
            
            Console.WriteLine();
            
            // 공격 능력 전략 생성 및 사용
            var attackAbility = new AttackAbility(50);
            context.SetStrategy(attackAbility);
            context.ExecuteStrategy();
            
            Console.WriteLine("\n==== 확장 능력 사용 테스트 ====\n");
            
            // 확장된 능력 전략 생성 및 사용
            var fireAttackAbility = new EnhancedAbility(
                new AttackAbility(40),
                AbilityAttributes.Fire | AbilityAttributes.Debuff,
                15,
                30,
                "불의 공격을 가하여 적에게 화상 데미지를 입힙니다."
            );
            
            context.SetStrategy(fireAttackAbility);
            context.ExecuteStrategy();
            
            Console.WriteLine();
            
            // 확장된 치유 능력 전략 생성 및 사용
            var enhancedHealingAbility = new EnhancedAbility(
                new HealingAbility(50),
                AbilityAttributes.Healing | AbilityAttributes.Buff,
                30,
                45,
                "강화된 치유 능력으로 많은 체력을 회복합니다."
            );
            
            context.SetStrategy(enhancedHealingAbility);
            context.ExecuteStrategy();
            
            Console.WriteLine("\n실행 완료. 아무 키나 누르면 종료.");
            Console.ReadKey();
        }
    }
}</code></pre>
                            </div>

                            <div class="code-block" id="cpp-code">
                                <h3>4.1 Strategy 인터페이스 정의</h3>
                                <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;

namespace StrategyPattern {

    // 컨텍스트 클래스 선언 (순환 참조 해결을 위함)
    class AbilityContext;

    // Strategy 인터페이스 - 모든 전략이 구현해야 하는 메서드 정의
    class IAbilityStrategy {
    public:
        virtual ~IAbilityStrategy() = default;
        
        // 능력 사용 시 그 효과를 정의하는 메서드
        virtual void Execute(AbilityContext& context) = 0;
        virtual std::string GetName() const = 0;
    };
    
    // Context 클래스 - 전략 객체를 사용하는 컨텍스트
    class AbilityContext {
    private:
        // 현재 전략 참조
        std::shared_ptr<IAbilityStrategy> _currentStrategy;
        
        // 컨텍스트 데이터
        std::string _playerName;
        int _playerLevel;
        int _healthPoints;
        
    public:
        AbilityContext(const std::string& playerName, int playerLevel, int healthPoints)
            : _playerName(playerName), _playerLevel(playerLevel), _healthPoints(healthPoints) {}
        
        // Getter/Setter 메서드
        std::string GetPlayerName() const { return _playerName; }
        int GetPlayerLevel() const { return _playerLevel; }
        int GetHealthPoints() const { return _healthPoints; }
        void SetHealthPoints(int value) { _healthPoints = value; }
        
        // 전략 설정 메서드
        void SetStrategy(std::shared_ptr<IAbilityStrategy> strategy) {
            _currentStrategy = strategy;
            std::cout << "전략이 '" << strategy->GetName() << "'로 설정되었습니다." << std::endl;
        }
        
        // 전략 실행 메서드
        void ExecuteStrategy() {
            if (!_currentStrategy) {
                std::cout << "전략이 설정되지 않았습니다." << std::endl;
                return;
            }
            
            // 전략에게 실행 위임
            _currentStrategy->Execute(*this);
        }
    };

} // namespace StrategyPattern</code></pre>

                                <h3>4.2 ConcreteStrategy 구현</h3>
                                <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;

namespace StrategyPattern {

    // 구체적인 전략 1 - 치유 능력
    class HealingAbility : public IAbilityStrategy {
    private:
        int _healingAmount;
        
    public:
        explicit HealingAbility(int healingAmount) : _healingAmount(healingAmount) {}
        
        std::string GetName() const override {
            return "치유 능력";
        }
        
        void Execute(AbilityContext& context) override {
            // 치유 로직 구현
            int oldHealth = context.GetHealthPoints();
            context.SetHealthPoints(oldHealth + _healingAmount);
            
            std::cout << context.GetPlayerName() << "이(가) " << GetName() << "을 사용했습니다!" << std::endl;
            std::cout << "체력이 " << oldHealth << "에서 " << context.GetHealthPoints() 
                      << "로 회복되었습니다." << std::endl;
        }
    };
    
    // 구체적인 전략 2 - 방어 능력
    class DefenseAbility : public IAbilityStrategy {
    private:
        int _defenseDuration;
        
    public:
        explicit DefenseAbility(int defenseDuration) : _defenseDuration(defenseDuration) {}
        
        std::string GetName() const override {
            return "방어 능력";
        }
        
        void Execute(AbilityContext& context) override {
            // 방어 로직 구현
            std::cout << context.GetPlayerName() << "이(가) " << GetName() << "을 사용했습니다!" << std::endl;
            std::cout << _defenseDuration << "초 동안 모든 데미지가 50% 감소합니다." << std::endl;
        }
    };
    
    // 구체적인 전략 3 - 공격 능력
    class AttackAbility : public IAbilityStrategy {
    private:
        int _attackPower;
        
    public:
        explicit AttackAbility(int attackPower) : _attackPower(attackPower) {}
        
        std::string GetName() const override {
            return "공격 능력";
        }
        
        void Execute(AbilityContext& context) override {
            // 공격 로직 구현
            int bonusDamage = context.GetPlayerLevel() * 5;
            int totalDamage = _attackPower + bonusDamage;
            
            std::cout << context.GetPlayerName() << "이(가) " << GetName() << "을 사용했습니다!" << std::endl;
            std::cout << "모든 적에게 " << totalDamage << "(기본: " << _attackPower 
                      << ", 보너스: " << bonusDamage << ") 데미지를 입혔습니다." << std::endl;
        }
    };

} // namespace StrategyPattern</code></pre>

                                <h3>4.3 Strategy 패턴 확장</h3>
                                <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;

namespace StrategyPattern {

    // 능력 특성을 나타내는 열거형 (배트필드 플래그)
    enum AbilityAttributes {
        None = 0,
        Fire = 1 << 0,
        Ice = 1 << 1,
        Lightning = 1 << 2,
        Earth = 1 << 3,
        Healing = 1 << 4,
        Buff = 1 << 5,
        Debuff = 1 << 6
    };
    
    // 비트 연산자 오버로딩 (OR)
    inline AbilityAttributes operator|(AbilityAttributes a, AbilityAttributes b) {
        return static_cast<AbilityAttributes>(static_cast<int>(a) | static_cast<int>(b));
    }
    
    // 비트 연산자 오버로딩 (AND)
    inline AbilityAttributes operator&(AbilityAttributes a, AbilityAttributes b) {
        return static_cast<AbilityAttributes>(static_cast<int>(a) & static_cast<int>(b));
    }
    
    // 확장된 Strategy 인터페이스
    class IEnhancedAbilityStrategy : public IAbilityStrategy {
    public:
        virtual AbilityAttributes GetAttributes() const = 0;
        virtual int GetCooldown() const = 0;
        virtual int GetManaCost() const = 0;
        virtual std::string GetDescription() const = 0;
    };
    
    // Decorator 패턴을 활용한 Enhanced 능력 구현
    class EnhancedAbility : public IEnhancedAbilityStrategy {
    private:
        std::shared_ptr<IAbilityStrategy> _baseAbility;
        AbilityAttributes _attributes;
        int _cooldown;
        int _manaCost;
        std::string _description;
        
    public:
        EnhancedAbility(
            std::shared_ptr<IAbilityStrategy> baseAbility,
            AbilityAttributes attributes,
            int cooldown,
            int manaCost,
            const std::string& description
        ) : _baseAbility(baseAbility),
            _attributes(attributes),
            _cooldown(cooldown),
            _manaCost(manaCost),
            _description(description) {}
        
        std::string GetName() const override {
            return _baseAbility->GetName();
        }
        
        AbilityAttributes GetAttributes() const override {
            return _attributes;
        }
        
        int GetCooldown() const override {
            return _cooldown;
        }
        
        int GetManaCost() const override {
            return _manaCost;
        }
        
        std::string GetDescription() const override {
            return _description;
        }
        
        void Execute(AbilityContext& context) override {
            // 기본 능력 실행
            _baseAbility->Execute(context);
            
            // 특성에 따른 추가 효과
            if ((_attributes & Fire) != None) {
                std::cout << "불 속성 효과: 목표에게 화상 데미지를 추가로 입힙니다." << std::endl;
            }
            
            if ((_attributes & Healing) != None) {
                std::cout << "치유 속성 효과: 시간에 따라 추가 체력을 회복합니다." << std::endl;
            }
            
            // 마나 소모 과정 시뮬레이션
            std::cout << "마나 " << _manaCost << " 소모, 쿨다운 " << _cooldown << "초 적용." << std::endl;
        }
    };

} // namespace StrategyPattern</code></pre>

                                <h3>4.4 사용 예시</h3>
                                <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;

int main() {
    using namespace StrategyPattern;
    
    std::cout << "플레이어 캠릭터 생성..." << std::endl;
    AbilityContext context("Player1", 10, 100);
    
    std::cout << "\n==== 기본 능력 사용 테스트 ====\n" << std::endl;
    
    // 치유 능력 전략 생성 및 사용
    auto healingAbility = std::make_shared<HealingAbility>(30);
    context.SetStrategy(healingAbility);
    context.ExecuteStrategy();
    
    std::cout << std::endl;
    
    // 방어 능력 전략 생성 및 사용
    auto defenseAbility = std::make_shared<DefenseAbility>(5);
    context.SetStrategy(defenseAbility);
    context.ExecuteStrategy();
    
    std::cout << std::endl;
    
    // 공격 능력 전략 생성 및 사용
    auto attackAbility = std::make_shared<AttackAbility>(50);
    context.SetStrategy(attackAbility);
    context.ExecuteStrategy();
    
    std::cout << "\n==== 확장 능력 사용 테스트 ====\n" << std::endl;
    
    // 확장된 능력 전략 생성 및 사용
    auto fireAttackAbility = std::make_shared<EnhancedAbility>(
        std::make_shared<AttackAbility>(40),
        Fire | Debuff,
        15,
        30,
        "불의 공격을 가하여 적에게 화상 데미지를 입힙니다."
    );
    
    context.SetStrategy(fireAttackAbility);
    context.ExecuteStrategy();
    
    std::cout << std::endl;
    
    // 확장된 치유 능력 전략 생성 및 사용
    auto enhancedHealingAbility = std::make_shared<EnhancedAbility>(
        std::make_shared<HealingAbility>(50),
        Healing | Buff,
        30,
        45,
        "강화된 치유 능력으로 많은 체력을 회복합니다."
    );
    
    context.SetStrategy(enhancedHealingAbility);
    context.ExecuteStrategy();
    
    std::cout << "\n실행 완료." << std::endl;
    
    return 0;
}</code></pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="content-section">
                    <h2>5. Strategy 패턴의 장단점</h2>
                    <div class="pattern-pros-cons">
                        <h3>5.1 장점</h3>
                        <ul>
                            <li>
                                <strong>런타임에 알고리즘 교체 가능</strong>
                                <p>실행 중에 객체의 동작을 변경할 수 있어 유연한 시스템 구축이 가능합니다.</p>
                            </li>
                            <li>
                                <strong>알고리즘의 분리 및 캡슐화</strong>
                                <p>각 알고리즘이 독립적인 클래스로 캡슐화되어 있어 관리와 확장이 용이합니다.</p>
                            </li>
                            <li>
                                <strong>조건문 제거</strong>
                                <p>복잡한 조건문을 전략 객체로 대체하여 코드의 가독성과 유지보수성이 향상됩니다.</p>
                            </li>
                            <li>
                                <strong>확장성 향상</strong>
                                <p>새로운 전략을 추가할 때 기존 코드를 수정하지 않고도 새로운 클래스만 추가하면 됩니다.</p>
                            </li>
                        </ul>

                        <h3>5.2 단점</h3>
                        <ul>
                            <li>
                                <strong>클래스 수 증가</strong>
                                <p>각 알고리즘마다 별도의 클래스가 필요하므로 전체 클래스 수가 증가할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>클라이언트의 복잡성</strong>
                                <p>클라이언트가 다양한 전략을 인식하고 선택해야 하므로 클라이언트의 복잡성이 증가할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>오버헤드 발생</strong>
                                <p>전략 객체 생성과 관리에 따른 추가적인 오버헤드가 발생할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>컨텍스트와 전략 간의 의사소통</strong>
                                <p>컨텍스트가 전략에 필요한 데이터를 전달하는 방식에 따라 추가적인 복잡성이 발생할 수 있습니다.</p>
                            </li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>6. Strategy 패턴 vs 다른 패턴</h2>
                    <div class="pattern-pros-cons">
                        <h3>6.1 Strategy vs State 패턴</h3>
                        <p>두 패턴 모두 컴포지션과 위임을 사용하지만, State 패턴은 객체의 상태에 따라 동작이 변하며 상태 전환이 자동으로 일어나는 반면, Strategy 패턴은 알고리즘을 캡슐화하고 클라이언트가 명시적으로 전략을 선택합니다.</p>
                        
                        <h3>6.2 Strategy vs Command 패턴</h3>
                        <p>Command 패턴은 요청을 객체로 캡슐화하여 매개변수화된 객체로 클라이언트를 다양한 요청으로부터 분리하는 반면, Strategy 패턴은 교체 가능한 알고리즘 군을 정의하여 알고리즘의 변형을 제공합니다.</p>
                        
                        <h3>6.3 Strategy vs Template Method 패턴</h3>
                        <p>Template Method 패턴은 상속을 통해 알고리즘의 일부를 하위 클래스에서 구현하게 하는 반면, Strategy 패턴은 구성(Composition)을 통해 전체 알고리즘을 캡슐화하고 교체 가능하게 만듭니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>7. 주의사항 및 모범 사례</h2>
                    <div class="pattern-pros-cons">
                        <ul>
                            <li>
                                <strong>전략 생성 및 관리</strong>
                                <p>전략 객체의 생성과 관리를 위해 Factory 패턴이나 Dependency Injection을 고려하세요.</p>
                            </li>
                            <li>
                                <strong>기본 전략 설정</strong>
                                <p>컨텍스트에 기본 전략을 설정하여 전략이 없는 상태를 방지하세요.</p>
                            </li>
                            <li>
                                <strong>전략 인터페이스 설계</strong>
                                <p>전략 인터페이스는 간결하게 유지하고, 필요한 메서드만 포함하도록 설계하세요.</p>
                            </li>
                            <li>
                                <strong>전략 재사용</strong>
                                <p>전략 객체가 상태를 유지하지 않는 경우, 싱글톤으로 구현하거나 객체 풀을 사용하여 메모리를 절약할 수 있습니다.</p>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2024 GameDev PatternHub. All rights reserved.</p>
        </div>
    </footer>

    <script src="../js/main.js"></script>
    <script>
        // 코드 하이라이팅 초기화
        document.addEventListener('DOMContentLoaded', (event) => {
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightBlock(block);
            });
        });

        // 언어 탭 전환
        const tabButtons = document.querySelectorAll('.tab-btn');
        const codeBlocks = document.querySelectorAll('.code-block');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const lang = button.getAttribute('data-lang');
                
                // 버튼 활성화 상태 변경
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                // 코드 블록 표시/숨김
                codeBlocks.forEach(block => {
                    block.classList.remove('active');
                    if (block.id === `${lang}-code`) {
                        block.classList.add('active');
                    }
                });
            });
        });
    </script>
</body>
</html>