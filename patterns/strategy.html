<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategy 패턴 - GameDev PatternHub</title>
    <link rel="stylesheet" href="../css/common.css">
    <link rel="stylesheet" href="../css/layout.css">
    <link rel="stylesheet" href="../css/pattern-detail.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <header class="header">
        <nav class="nav-container">
            <div class="logo">
                <h1>GameDev PatternHub</h1>
            </div>
            <div class="nav-links">
                <a href="../index.html">홈</a>
                <a href="../patterns.html">패턴 목록</a>
                <a href="#">데모 게임</a>
                <a href="#">문서</a>
                <button id="theme-toggle" class="theme-toggle" aria-label="다크 모드 전환">
                    <i class="fas fa-moon"></i>
                </button>
            </div>
            <button class="mobile-menu-btn">
                <i class="fas fa-bars"></i>
            </button>
        </nav>
    </header>

    <main class="pattern-detail">
        <section class="pattern-header">
            <div class="container">
                <h1>Strategy 패턴</h1>
                <div class="pattern-meta">
                    <span class="category">행동 패턴</span>
                    <span class="difficulty">난이도: ★★★☆☆</span>
                </div>
            </div>
        </section>

        <section class="pattern-content">
            <div class="container">
                <div class="content-section">
                    <h2>패턴 개요</h2>
                    <p>Strategy 패턴은 알고리즘 군을 정의하고, 각각을 캡슐화하여 상호 교환 가능하게 만드는 디자인 패턴입니다. 이 패턴을 사용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있으며, 런타임에 알고리즘을 교체할 수 있습니다.</p>
                    
                    <div class="pattern-benefits">
                        <h3>주요 장점</h3>
                        <ul>
                            <li>알고리즘을 쉽게 교체할 수 있는 유연성 제공</li>
                            <li>조건문을 줄여 코드 가독성 향상</li>
                            <li>새로운 전략 추가가 용이하여 확장성이 높음</li>
                            <li>각 알고리즘을 캡슐화하여 재사용성 증가</li>
                            <li>책임의 분리를 통한 유지보수성 향상</li>
                        </ul>
                    </div>

                    <div class="pattern-use-cases">
                        <h3>사용 사례</h3>
                        <ul>
                            <li>게임 캐릭터의 다양한 공격 방식 구현</li>
                            <li>AI 행동 패턴 정의 및 전환</li>
                            <li>게임 난이도에 따른 다양한 동작 방식 구현</li>
                            <li>이동, 점프, 회피 등 다양한 캐릭터 능력 구현</li>
                            <li>경로 탐색이나 의사 결정 알고리즘 전환</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>1. Strategy 패턴의 기본 개념</h2>
                    <div class="pattern-types">
                        <h3>1.1 패턴 구성 요소</h3>
                        <ul>
                            <li><strong>Strategy (전략) 인터페이스</strong>: 모든 구체적인 전략이 구현해야 하는 공통 인터페이스를 정의합니다.</li>
                            <li><strong>ConcreteStrategy (구체적인 전략)</strong>: Strategy 인터페이스를 구현하는 다양한 알고리즘 클래스들입니다.</li>
                            <li><strong>Context (컨텍스트)</strong>: Strategy 객체를 참조하고 사용하는 클래스입니다. 런타임에 다른 전략으로 교체할 수 있는 메서드를 제공합니다.</li>
                        </ul>
                        
                        <h3>1.2 패턴 작동 방식</h3>
                        <p>컨텍스트 객체는 전략 객체의 레퍼런스를 유지하며, 실제 작업을 처리할 때 해당 전략 객체에게 작업을 위임합니다. 클라이언트는 원하는 전략을 선택하고 컨텍스트에 설정할 수 있으며, 런타임에 전략을 변경할 수 있습니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>2. 왜 Strategy 패턴을 사용해야 하는가?</h2>
                    <div class="pattern-benefits">
                        <h3>2.1 유연한 알고리즘 교체</h3>
                        <p>조건문이나 상속 대신 전략 객체를 교체하는 방식으로 런타임에 동작을 변경할 수 있어 코드의 유연성이 향상됩니다.</p>
                        
                        <h3>2.2 조건문 제거</h3>
                        <p>여러 조건에 따라 다른 알고리즘을 사용하는 복잡한 조건문을 제거하고, 각 알고리즘을 개별 클래스로 캡슐화하여 코드의 명확성이 높아집니다.</p>
                        
                        <h3>2.3 Open/Closed 원칙 준수</h3>
                        <p>새로운 전략을 추가할 때 기존 코드를 수정하지 않고도 확장할 수 있어 Open/Closed 원칙을 준수합니다.</p>
                        
                        <h3>2.4 재사용성 향상</h3>
                        <p>각 알고리즘이 독립적인 클래스로 캡슐화되어 있어 다른 컨텍스트에서도 재사용이 가능합니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>3. 어떤 상황에서 사용해야 하는가?</h2>
                    <div class="pattern-use-cases">
                        <h3>3.1 다양한 알고리즘 변형이 필요한 경우</h3>
                        <p>게임에서 AI 캐릭터의 다양한 행동 패턴, 다른 타입의 무기, 다양한 이동 방식 등 여러 알고리즘 변형이 필요할 때 적합합니다.</p>
                        
                        <h3>3.2 런타임에 동작 교체가 필요한 경우</h3>
                        <p>게임 진행 중 캐릭터의 능력이 변하거나, 상황에 따라 다른 전략을 사용해야 할 때 유용합니다.</p>
                        
                        <h3>3.3 조건문이 복잡해지는 경우</h3>
                        <p>동작 방식을 결정하는 조건문이 너무 복잡해질 때, 전략 패턴을 사용하여 각 동작을 개별 클래스로 분리하면 코드가 간결해집니다.</p>
                        
                        <h3>3.4 클래스 상속으로 인한 문제가 발생할 경우</h3>
                        <p>상속을 통해 여러 알고리즘을 처리하려고 할 때 클래스 계층 구조가 복잡해지는 경우, 전략 패턴을 사용하여 구성(Composition)으로 문제를 해결할 수 있습니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>4. 어떻게 구현하는가?</h2>
                    <p>Strategy 패턴의 구현은 다양한 언어로 가능합니다. 아래 링크를 통해 각 언어별 구현 코드를 확인할 수 있습니다.</p>
                    
                    <div class="code-tabs">
                        <div class="code-language-buttons">
                            <a href="codes/strategy_csharp.html" class="code-language-btn">C# 코드 보기 <i class="fas fa-code"></i></a>
                            <a href="codes/strategy_cpp.html" class="code-language-btn">C++ 코드 보기 <i class="fas fa-code"></i></a>
                        </div>
                    </div>
                </div>

                <div class="content-section">
                    <h2>5. Strategy 패턴의 장단점</h2>
                    <div class="pattern-pros-cons">
                        <h3>5.1 장점</h3>
                        <ul>
                            <li>
                                <strong>런타임에 알고리즘 교체 가능</strong>
                                <p>실행 중에 객체의 동작을 변경할 수 있어 유연한 시스템 구축이 가능합니다.</p>
                            </li>
                            <li>
                                <strong>알고리즘의 분리 및 캡슐화</strong>
                                <p>각 알고리즘이 독립적인 클래스로 캡슐화되어 있어 관리와 확장이 용이합니다.</p>
                            </li>
                            <li>
                                <strong>조건문 제거</strong>
                                <p>복잡한 조건문을 전략 객체로 대체하여 코드의 가독성과 유지보수성이 향상됩니다.</p>
                            </li>
                            <li>
                                <strong>확장성 향상</strong>
                                <p>새로운 전략을 추가할 때 기존 코드를 수정하지 않고도 새로운 클래스만 추가하면 됩니다.</p>
                            </li>
                        </ul>

                        <h3>5.2 단점</h3>
                        <ul>
                            <li>
                                <strong>클래스 수 증가</strong>
                                <p>각 알고리즘마다 별도의 클래스가 필요하므로 전체 클래스 수가 증가할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>클라이언트의 복잡성</strong>
                                <p>클라이언트가 다양한 전략을 인식하고 선택해야 하므로 클라이언트의 복잡성이 증가할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>오버헤드 발생</strong>
                                <p>전략 객체 생성과 관리에 따른 추가적인 오버헤드가 발생할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>컨텍스트와 전략 간의 의사소통</strong>
                                <p>컨텍스트가 전략에 필요한 데이터를 전달하는 방식에 따라 추가적인 복잡성이 발생할 수 있습니다.</p>
                            </li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>6. Strategy 패턴 vs 다른 패턴</h2>
                    <div class="pattern-pros-cons">
                        <h3>6.1 Strategy vs State 패턴</h3>
                        <p>두 패턴 모두 컴포지션과 위임을 사용하지만, State 패턴은 객체의 상태에 따라 동작이 변하며 상태 전환이 자동으로 일어나는 반면, Strategy 패턴은 알고리즘을 캡슐화하고 클라이언트가 명시적으로 전략을 선택합니다.</p>
                        
                        <h3>6.2 Strategy vs Command 패턴</h3>
                        <p>Command 패턴은 요청을 객체로 캡슐화하여 매개변수화된 객체로 클라이언트를 다양한 요청으로부터 분리하는 반면, Strategy 패턴은 교체 가능한 알고리즘 군을 정의하여 알고리즘의 변형을 제공합니다.</p>
                        
                        <h3>6.3 Strategy vs Template Method 패턴</h3>
                        <p>Template Method 패턴은 상속을 통해 알고리즘의 일부를 하위 클래스에서 구현하게 하는 반면, Strategy 패턴은 구성(Composition)을 통해 전체 알고리즘을 캡슐화하고 교체 가능하게 만듭니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>7. 주의사항 및 모범 사례</h2>
                    <div class="pattern-pros-cons">
                        <ul>
                            <li>
                                <strong>전략 생성 및 관리</strong>
                                <p>전략 객체의 생성과 관리를 위해 Factory 패턴이나 Dependency Injection을 고려하세요.</p>
                            </li>
                            <li>
                                <strong>기본 전략 설정</strong>
                                <p>컨텍스트에 기본 전략을 설정하여 전략이 없는 상태를 방지하세요.</p>
                            </li>
                            <li>
                                <strong>전략 인터페이스 설계</strong>
                                <p>전략 인터페이스는 간결하게 유지하고, 필요한 메서드만 포함하도록 설계하세요.</p>
                            </li>
                            <li>
                                <strong>전략 재사용</strong>
                                <p>전략 객체가 상태를 유지하지 않는 경우, 싱글톤으로 구현하거나 객체 풀을 사용하여 메모리를 절약할 수 있습니다.</p>
                            </li>
                        </ul>
                    </div>
                </div>
                
                <div class="navigation-buttons">
                    <a href="../patterns.html" class="back-button"><i class="fas fa-arrow-left"></i> 패턴 목록으로 돌아가기</a>
                    <a href="codes/strategy_csharp.html" class="next-button">C# 코드 예제 보기 <i class="fas fa-arrow-right"></i></a>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2025 GameDev PatternHub. All rights reserved.</p>
        </div>
    </footer>

    <script src="../js/main.js"></script>
</body>
</html>