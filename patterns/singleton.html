<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Singleton 패턴 - GameDev PatternHub</title>
    <link rel="stylesheet" href="../css/common.css">
    <link rel="stylesheet" href="../css/layout.css">
    <link rel="stylesheet" href="../css/pattern-detail.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js"></script>
</head>
<body>
    <header class="header">
        <nav class="nav-container">
            <div class="logo">
                <h1>GameDev PatternHub</h1>
            </div>
            <div class="nav-links">
                <a href="../index.html">홈</a>
                <a href="../patterns.html">패턴 목록</a>
                <a href="#">데모 게임</a>
                <a href="#">문서</a>
            </div>
            <button class="mobile-menu-btn">
                <i class="fas fa-bars"></i>
            </button>
        </nav>
    </header>

    <main class="pattern-detail">
        <section class="pattern-header">
            <div class="container">
                <h1>Singleton 패턴</h1>
                <div class="pattern-meta">
                    <span class="category">생성 패턴</span>
                    <span class="difficulty">난이도: ★★☆☆☆</span>
                </div>
            </div>
        </section>

        <section class="pattern-content">
            <div class="container">
                <div class="content-section">
                    <h2>패턴 개요</h2>
                    <p>Singleton 패턴은 클래스의 인스턴스가 애플리케이션 내에서 단 하나만 존재하도록 보장하고, 이 인스턴스에 대한 전역적인 접근점을 제공하는 디자인 패턴입니다. 게임 개발에서는 GameManager, AudioManager, InputManager 등 전체 게임에서 하나의 인스턴스만 필요한 컴포넌트에 주로 사용됩니다.</p>
                    
                    <div class="pattern-benefits">
                        <h3>주요 장점</h3>
                        <ul>
                            <li>전역적으로 접근 가능한 단일 인스턴스 보장</li>
                            <li>게임의 상태나 리소스를 중앙 집중식으로 관리 가능</li>
                            <li>여러 객체 간의 일관된 정보 공유 용이</li>
                            <li>중복 인스턴스 생성 방지로 리소스 절약</li>
                        </ul>
                    </div>

                    <div class="pattern-use-cases">
                        <h3>사용 사례</h3>
                        <ul>
                            <li>게임 매니저 (점수, 난이도, 게임 상태 관리)</li>
                            <li>오디오 매니저 (사운드 효과, 배경 음악 제어)</li>
                            <li>입력 시스템 (키보드, 마우스, 터치 입력 처리)</li>
                            <li>씬 관리자 (레벨 로드, 전환 효과)</li>
                            <li>리소스 매니저 (에셋 로드 및 캐싱)</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>1. Singleton 패턴의 기본 개념</h2>
                    <p>Singleton 패턴의 핵심은 다음과 같습니다:</p>
                    <div class="pattern-pros-cons">
                        <ul>
                            <li>클래스의 인스턴스가 하나만 존재하도록 보장</li>
                            <li>인스턴스에 대한 전역적인 접근점 제공</li>
                            <li>생성자를 private으로 선언하여 외부에서 인스턴스 생성 방지</li>
                            <li>정적 메서드를 통한 인스턴스 접근</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>2. 왜 Singleton 패턴을 사용해야 하는가?</h2>
                    <div class="pattern-benefits">
                        <h3>2.1 단일 인스턴스 보장</h3>
                        <p>게임에서는 특정 매니저 클래스들이 중복으로 생성되면 데이터 불일치, 메모리 낭비, 충돌 등의 문제가 발생할 수 있습니다. Singleton 패턴은 이러한 문제를 방지하고 하나의 인스턴스만 존재하도록 보장합니다.</p>
                        
                        <h3>2.2 전역 접근성</h3>
                        <p>게임의 어떤 부분에서든 쉽게 접근할 수 있는 전역 접근점을 제공합니다. 이는 게임의 여러 시스템 간에 정보를 공유하거나 통신할 때 특히 유용합니다.</p>
                        
                        <h3>2.3 중앙 집중식 관리</h3>
                        <p>게임 상태, 설정, 리소스 등을 중앙에서 관리함으로써 일관성을 유지하고 코드의 복잡성을 줄일 수 있습니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>3. 어떤 상황에서 사용해야 하는가?</h2>
                    <div class="pattern-use-cases">
                        <h3>3.1 전역 상태 관리가 필요한 경우</h3>
                        <p>게임 점수, 생명력, 레벨 정보 등 게임 전체에서 공유되어야 하는 상태 정보를 관리할 때 적합합니다.</p>
                        
                        <h3>3.2 리소스 관리가 필요한 경우</h3>
                        <p>오디오, 텍스처, 프리팹 등 게임에서 자주 사용되는 리소스를 로드하고 캐싱하는 매니저에 적합합니다.</p>
                        
                        <h3>3.3 시스템 간 통신이 필요한 경우</h3>
                        <p>UI, 게임 로직, 오디오 등 게임의 다양한 시스템 간의 통신을 단순화할 때 유용합니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>4. 어떻게 구현하는가?</h2>
                    <div class="code-tabs">
                        <div class="tab-buttons">
                            <button class="tab-btn active" data-lang="csharp">C#</button>
                            <button class="tab-btn" data-lang="cpp">C++</button>
                        </div>
                        
                        <div class="tab-content">
                            <div class="code-block active" id="csharp-code">
                                <h3>4.1 기본 Singleton</h3>
                                <pre><code class="language-csharp">using System;

namespace SingletonPattern
{
    // 기본 싱글톤 클래스
    public class Singleton
    {
        // 유일한 인스턴스를 저장하는 정적 변수
        private static Singleton _instance;

        // 외부에서 인스턴스에 접근할 수 있는 프로퍼티
        public static Singleton Instance
        {
            get
            {
                // 인스턴스가 없으면 새로 생성
                if (_instance == null)
                {
                    _instance = new Singleton();
                }
                return _instance;
            }
        }

        // 생성자를 private으로 선언하여 외부에서 인스턴스 생성 방지
        private Singleton()
        {
            Console.WriteLine("Singleton 인스턴스가 생성되었습니다.");
        }

        // 싱글톤에서 제공하는 메서드 예시
        public void DoSomething()
        {
            Console.WriteLine("Singleton이 작업을 수행 중입니다.");
        }
    }
}</code></pre>

                                <h3>4.2 스레드 안전한 Singleton</h3>
                                <pre><code class="language-csharp">using System;

namespace SingletonPattern
{
    // 스레드 안전한 싱글톤 구현
    public class ThreadSafeSingleton
    {
        private static volatile ThreadSafeSingleton _instance;
        private static readonly object _lock = new object();

        public static ThreadSafeSingleton Instance
        {
            get
            {
                // 이중 체크 잠금(Double-Check Locking) 패턴 사용
                if (_instance == null)
                {
                    lock (_lock)
                    {
                        if (_instance == null)
                        {
                            _instance = new ThreadSafeSingleton();
                        }
                    }
                }
                return _instance;
            }
        }

        private ThreadSafeSingleton()
        {
            Console.WriteLine("ThreadSafeSingleton 인스턴스가 생성되었습니다.");
        }

        public void DoSomething()
        {
            Console.WriteLine("ThreadSafeSingleton이 작업을 수행 중입니다.");
        }
    }
}</code></pre>

                                <h3>4.3 사용 예시</h3>
                                <pre><code class="language-csharp">using System;

namespace SingletonPattern
{
    class Program
    {
        static void Main(string[] args)
        {
            // 기본 싱글톤 사용 예시
            Singleton singleton1 = Singleton.Instance;
            Singleton singleton2 = Singleton.Instance;
            
            Console.WriteLine($"singleton1과 singleton2는 같은 인스턴스인가? {singleton1 == singleton2}");
            singleton1.DoSomething();

            // 스레드 안전한 싱글톤 사용 예시
            ThreadSafeSingleton safeSingleton = ThreadSafeSingleton.Instance;
            safeSingleton.DoSomething();
        }
    }
}</code></pre>
                            </div>

                            <div class="code-block" id="cpp-code">
                                <h3>4.1 기본 Singleton</h3>
                                <pre><code class="language-cpp">#include &lt;iostream&gt;

class Singleton {
private:
    // 정적 인스턴스 포인터
    static Singleton* instance;
    
    // private 생성자로 외부에서의 인스턴스 생성 방지
    Singleton() {
        std::cout << "Singleton 인스턴스가 생성되었습니다." << std::endl;
    }
    
    // 복사 생성자와 할당 연산자를 private으로 선언하여 복제 방지
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    
public:
    // 인스턴스 접근 메서드
    static Singleton* getInstance() {
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return instance;
    }
    
    // 싱글톤에서 제공하는 메서드 예시
    void doSomething() {
        std::cout << "Singleton이 작업을 수행 중입니다." << std::endl;
    }
    
    // 인스턴스 정리 (메모리 누수 방지)
    static void release() {
        if (instance != nullptr) {
            delete instance;
            instance = nullptr;
        }
    }
};

// 정적 멤버 변수 초기화
Singleton* Singleton::instance = nullptr;</code></pre>

                                <h3>4.2 안전한 Singleton (C++11 이상)</h3>
                                <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;mutex&gt;

class ThreadSafeSingleton {
private:
    static std::unique_ptr&lt;ThreadSafeSingleton&gt; instance;
    static std::mutex mutex;
    
    // private 생성자
    ThreadSafeSingleton() {
        std::cout << "ThreadSafeSingleton 인스턴스가 생성되었습니다." << std::endl;
    }
    
    // 복사 및 할당 방지
    ThreadSafeSingleton(const ThreadSafeSingleton&) = delete;
    ThreadSafeSingleton& operator=(const ThreadSafeSingleton&) = delete;
    
public:
    // 인스턴스 접근 메서드 (스레드 안전)
    static ThreadSafeSingleton& getInstance() {
        std::lock_guard&lt;std::mutex&gt; lock(mutex);
        if (instance == nullptr) {
            instance.reset(new ThreadSafeSingleton());
        }
        return *instance;
    }
    
    void doSomething() {
        std::cout << "ThreadSafeSingleton이 작업을 수행 중입니다." << std::endl;
    }
};

// 정적 멤버 변수 초기화
std::unique_ptr&lt;ThreadSafeSingleton&gt; ThreadSafeSingleton::instance = nullptr;
std::mutex ThreadSafeSingleton::mutex;</code></pre>

                                <h3>4.3 사용 예시</h3>
                                <pre><code class="language-cpp">#include &lt;iostream&gt;
#include "singleton.h"  // 위의 싱글톤 클래스가 정의된 헤더 파일

int main() {
    // 기본 싱글톤 사용 예시
    Singleton* singleton1 = Singleton::getInstance();
    Singleton* singleton2 = Singleton::getInstance();
    
    std::cout << "singleton1과 singleton2는 같은 인스턴스인가? " 
              << (singleton1 == singleton2 ? "True" : "False") << std::endl;
    
    singleton1->doSomething();
    
    // 스레드 안전한 싱글톤 사용 예시
    ThreadSafeSingleton& safeSingleton = ThreadSafeSingleton::getInstance();
    safeSingleton.doSomething();
    
    // 기본 싱글톤 메모리 해제 (스마트 포인터를 사용하지 않는 경우)
    Singleton::release();
    
    return 0;
}</code></pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="content-section">
                    <h2>5. Singleton 패턴의 장단점</h2>
                    <div class="pattern-pros-cons">
                        <h3>5.1 장점</h3>
                        <ul>
                            <li>
                                <strong>단일 인스턴스 보장</strong>
                                <p>클래스의 인스턴스가 하나만 존재함을 보장하여 중복 생성으로 인한 문제를 방지합니다.</p>
                            </li>
                            <li>
                                <strong>전역 접근성</strong>
                                <p>애플리케이션 어디서든 해당 인스턴스에 접근할 수 있어 정보 공유가 용이합니다.</p>
                            </li>
                            <li>
                                <strong>지연 초기화</strong>
                                <p>인스턴스가 필요할 때만 생성되도록 할 수 있어 리소스를 효율적으로 사용할 수 있습니다.</p>
                            </li>
                        </ul>

                        <h3>5.2 단점</h3>
                        <ul>
                            <li>
                                <strong>전역 상태의 위험성</strong>
                                <p>전역 상태는 코드 간의 결합도를 높이고, 어디서든 접근 가능하여 예측하기 어려운 동작을 일으킬 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>단위 테스트의 어려움</strong>
                                <p>싱글톤 패턴은 의존성을 숨기므로 단위 테스트가 어려워질 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>멀티스레드 환경에서의 동기화 문제</strong>
                                <p>멀티스레드 환경에서는 적절한 동기화 처리가 없으면 경쟁 상태(race condition)가 발생할 수 있습니다.</p>
                            </li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>6. 주의사항 및 모범 사례</h2>
                    <div class="pattern-pros-cons">
                        <ul>
                            <li>
                                <strong>과도한 사용 지양</strong>
                                <p>Singleton 패턴은 필요한 경우에만 사용하고, 모든 매니저 클래스를 싱글톤으로 만드는 것은 피해야 합니다.</p>
                            </li>
                            <li>
                                <strong>스레드 안전성 고려</strong>
                                <p>멀티스레드 환경에서는 이중 검사 잠금(Double-Check Locking)과 같은 패턴을 사용하여 스레드 안전성을 확보해야 합니다.</p>
                            </li>
                            <li>
                                <strong>의존성 관리</strong>
                                <p>Singleton에 대한 의존성을 명시적으로 표현하고, 필요한 경우 의존성 주입을 고려하세요.</p>
                            </li>
                            <li>
                                <strong>메모리 관리</strong>
                                <p>C++에서는 메모리 누수를 방지하기 위해 리소스 해제 메커니즘을 구현하는 것이 중요합니다.</p>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2024 GameDev PatternHub. All rights reserved.</p>
        </div>
    </footer>

    <script src="../js/main.js"></script>
    <script>
        // 코드 하이라이팅 초기화
        document.addEventListener('DOMContentLoaded', (event) => {
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightBlock(block);
            });
        });

        // 언어 탭 전환
        const tabButtons = document.querySelectorAll('.tab-btn');
        const codeBlocks = document.querySelectorAll('.code-block');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const lang = button.getAttribute('data-lang');
                
                // 버튼 활성화 상태 변경
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                // 코드 블록 표시/숨김
                codeBlocks.forEach(block => {
                    block.classList.remove('active');
                    if (block.id === `${lang}-code`) {
                        block.classList.add('active');
                    }
                });
            });
        });
    </script>
</body>
</html>