<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Singleton 패턴 - GameDev PatternHub</title>
    <link rel="stylesheet" href="../css/common.css">
    <link rel="stylesheet" href="../css/layout.css">
    <link rel="stylesheet" href="../css/pattern-detail.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <header class="header">
        <nav class="nav-container">
            <div class="logo">
                <h1>GameDev PatternHub</h1>
            </div>
            <div class="nav-links">
                <a href="../index.html">홈</a>
                <a href="../patterns.html">패턴 목록</a>
                <a href="#">데모 게임</a>
                <a href="#">문서</a>
                <button id="theme-toggle" class="theme-toggle" aria-label="다크 모드 전환">
                    <i class="fas fa-moon"></i>
                </button>
            </div>
            <button class="mobile-menu-btn">
                <i class="fas fa-bars"></i>
            </button>
        </nav>
    </header>

    <main class="pattern-detail">
        <section class="pattern-header">
            <div class="container">
                <h1>Singleton 패턴</h1>
                <div class="pattern-meta">
                    <span class="category">생성 패턴</span>
                    <span class="difficulty">난이도: ★★☆☆☆</span>
                </div>
            </div>
        </section>

        <section class="pattern-content">
            <div class="container">
                <div class="content-section">
                    <h2>패턴 개요</h2>
                    <p>Singleton 패턴은 클래스의 인스턴스가 애플리케이션 내에서 단 하나만 존재하도록 보장하고, 이 인스턴스에 대한 전역적인 접근점을 제공하는 디자인 패턴입니다. 게임 개발에서는 GameManager, AudioManager, InputManager 등 전체 게임에서 하나의 인스턴스만 필요한 컴포넌트에 주로 사용됩니다.</p>
                    
                    <div class="pattern-benefits">
                        <h3>주요 장점</h3>
                        <ul>
                            <li>전역적으로 접근 가능한 단일 인스턴스 보장</li>
                            <li>게임의 상태나 리소스를 중앙 집중식으로 관리 가능</li>
                            <li>여러 객체 간의 일관된 정보 공유 용이</li>
                            <li>중복 인스턴스 생성 방지로 리소스 절약</li>
                        </ul>
                    </div>

                    <div class="pattern-use-cases">
                        <h3>사용 사례</h3>
                        <ul>
                            <li>게임 매니저 (점수, 난이도, 게임 상태 관리)</li>
                            <li>오디오 매니저 (사운드 효과, 배경 음악 제어)</li>
                            <li>입력 시스템 (키보드, 마우스, 터치 입력 처리)</li>
                            <li>씬 관리자 (레벨 로드, 전환 효과)</li>
                            <li>리소스 매니저 (에셋 로드 및 캐싱)</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>1. Singleton 패턴의 기본 개념</h2>
                    <p>Singleton 패턴의 핵심은 다음과 같습니다:</p>
                    <div class="pattern-pros-cons">
                        <ul>
                            <li>클래스의 인스턴스가 하나만 존재하도록 보장</li>
                            <li>인스턴스에 대한 전역적인 접근점 제공</li>
                            <li>생성자를 private으로 선언하여 외부에서 인스턴스 생성 방지</li>
                            <li>정적 메서드를 통한 인스턴스 접근</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>2. 왜 Singleton 패턴을 사용해야 하는가?</h2>
                    <div class="pattern-benefits">
                        <h3>2.1 단일 인스턴스 보장</h3>
                        <p>게임에서는 특정 매니저 클래스들이 중복으로 생성되면 데이터 불일치, 메모리 낭비, 충돌 등의 문제가 발생할 수 있습니다. Singleton 패턴은 이러한 문제를 방지하고 하나의 인스턴스만 존재하도록 보장합니다.</p>
                        
                        <h3>2.2 전역 접근성</h3>
                        <p>게임의 어떤 부분에서든 쉽게 접근할 수 있는 전역 접근점을 제공합니다. 이는 게임의 여러 시스템 간에 정보를 공유하거나 통신할 때 특히 유용합니다.</p>
                        
                        <h3>2.3 중앙 집중식 관리</h3>
                        <p>게임 상태, 설정, 리소스 등을 중앙에서 관리함으로써 일관성을 유지하고 코드의 복잡성을 줄일 수 있습니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>3. 어떤 상황에서 사용해야 하는가?</h2>
                    <div class="pattern-use-cases">
                        <h3>3.1 전역 상태 관리가 필요한 경우</h3>
                        <p>게임 점수, 생명력, 레벨 정보 등 게임 전체에서 공유되어야 하는 상태 정보를 관리할 때 적합합니다.</p>
                        
                        <h3>3.2 리소스 관리가 필요한 경우</h3>
                        <p>오디오, 텍스처, 프리팹 등 게임에서 자주 사용되는 리소스를 로드하고 캐싱하는 매니저에 적합합니다.</p>
                        
                        <h3>3.3 시스템 간 통신이 필요한 경우</h3>
                        <p>UI, 게임 로직, 오디오 등 게임의 다양한 시스템 간의 통신을 단순화할 때 유용합니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>4. 어떻게 구현하는가?</h2>
                    <p>Singleton 패턴의 구현은 다양한 언어로 가능합니다. 아래 링크를 통해 각 언어별 구현 코드를 확인할 수 있습니다.</p>
                    
                    <div class="code-tabs">
                        <div class="code-language-buttons">
                            <a href="codes/singleton_csharp.html" class="code-language-btn">C# 코드 보기 <i class="fas fa-code"></i></a>
                            <a href="codes/singleton_cpp.html" class="code-language-btn">C++ 코드 보기 <i class="fas fa-code"></i></a>
                        </div>
                    </div>
                </div>

                <div class="content-section">
                    <h2>5. Singleton 패턴의 장단점</h2>
                    <div class="pattern-pros-cons">
                        <h3>5.1 장점</h3>
                        <ul>
                            <li>
                                <strong>단일 인스턴스 보장</strong>
                                <p>클래스의 인스턴스가 하나만 존재함을 보장하여 중복 생성으로 인한 문제를 방지합니다.</p>
                            </li>
                            <li>
                                <strong>전역 접근성</strong>
                                <p>애플리케이션 어디서든 해당 인스턴스에 접근할 수 있어 정보 공유가 용이합니다.</p>
                            </li>
                            <li>
                                <strong>지연 초기화</strong>
                                <p>인스턴스가 필요할 때만 생성되도록 할 수 있어 리소스를 효율적으로 사용할 수 있습니다.</p>
                            </li>
                        </ul>

                        <h3>5.2 단점</h3>
                        <ul>
                            <li>
                                <strong>전역 상태의 위험성</strong>
                                <p>전역 상태는 코드 간의 결합도를 높이고, 어디서든 접근 가능하여 예측하기 어려운 동작을 일으킬 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>단위 테스트의 어려움</strong>
                                <p>싱글톤 패턴은 의존성을 숨기므로 단위 테스트가 어려워질 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>멀티스레드 환경에서의 동기화 문제</strong>
                                <p>멀티스레드 환경에서는 적절한 동기화 처리가 없으면 경쟁 상태(race condition)가 발생할 수 있습니다.</p>
                            </li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>6. 주의사항 및 모범 사례</h2>
                    <div class="pattern-pros-cons">
                        <ul>
                            <li>
                                <strong>과도한 사용 지양</strong>
                                <p>Singleton 패턴은 필요한 경우에만 사용하고, 모든 매니저 클래스를 싱글톤으로 만드는 것은 피해야 합니다.</p>
                            </li>
                            <li>
                                <strong>스레드 안전성 고려</strong>
                                <p>멀티스레드 환경에서는 이중 검사 잠금(Double-Check Locking)과 같은 패턴을 사용하여 스레드 안전성을 확보해야 합니다.</p>
                            </li>
                            <li>
                                <strong>의존성 관리</strong>
                                <p>Singleton에 대한 의존성을 명시적으로 표현하고, 필요한 경우 의존성 주입을 고려하세요.</p>
                            </li>
                            <li>
                                <strong>메모리 관리</strong>
                                <p>C++에서는 메모리 누수를 방지하기 위해 리소스 해제 메커니즘을 구현하는 것이 중요합니다.</p>
                            </li>
                        </ul>
                    </div>
                </div>
                
                <div class="navigation-buttons">
                    <a href="../patterns.html" class="back-button"><i class="fas fa-arrow-left"></i> 패턴 목록으로 돌아가기</a>
                    <a href="codes/singleton_csharp.html" class="next-button">C# 코드 예제 보기 <i class="fas fa-arrow-right"></i></a>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2025 GameDev PatternHub. All rights reserved.</p>
        </div>
    </footer>

    <script src="../js/main.js"></script>
</body>
</html>