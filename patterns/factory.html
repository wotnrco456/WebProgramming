<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Factory 패턴 - GameDev PatternHub</title>
    <link rel="stylesheet" href="../css/common.css">
    <link rel="stylesheet" href="../css/layout.css">
    <link rel="stylesheet" href="../css/pattern-detail.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <header class="header">
        <nav class="nav-container">
            <div class="logo">
                <h1>GameDev PatternHub</h1>
            </div>
            <div class="nav-links">
                <a href="../index.html">홈</a>
                <a href="../patterns.html">패턴 목록</a>
                <a href="#">데모 게임</a>
                <a href="#">문서</a>
            </div>
            <button class="mobile-menu-btn">
                <i class="fas fa-bars"></i>
            </button>
        </nav>
    </header>

    <main class="pattern-detail">
        <section class="pattern-header">
            <div class="container">
                <h1>Factory 패턴</h1>
                <div class="pattern-meta">
                    <span class="category">생성 패턴</span>
                    <span class="difficulty">난이도: ★★☆☆☆</span>
                </div>
            </div>
        </section>

        <section class="pattern-content">
            <div class="container">
                <div class="content-section">
                    <h2>패턴 개요</h2>
                    <p>Factory 패턴은 객체 생성 로직을 캡슐화하여 유연한 객체 생성이 가능하게 하는 디자인 패턴입니다. 이 패턴은 객체의 생성과 사용을 분리하여 코드의 유지보수성과 확장성을 높입니다.</p>
                    
                    <div class="pattern-benefits">
                        <h3>주요 장점</h3>
                        <ul>
                            <li>객체 생성 로직을 한 곳에서 관리하여 코드 중복을 방지</li>
                            <li>새로운 타입의 객체 추가가 용이하여 확장성이 높음</li>
                            <li>클라이언트 코드와 구체적인 클래스 간의 결합도 감소</li>
                            <li>객체 생성 과정의 일관성 유지</li>
                            <li>인터페이스에 맞춰 코딩하여 시스템의 변화에 유연하게 대응 가능</li>
                        </ul>
                    </div>

                    <div class="pattern-use-cases">
                        <h3>사용 사례</h3>
                        <ul>
                            <li>게임 오브젝트 생성 (캐릭터, 아이템, 효과 등)</li>
                            <li>UI 요소 생성</li>
                            <li>레벨 디자인에서 다양한 오브젝트 생성</li>
                            <li>리소스 로딩 및 관리</li>
                            <li>다양한 타입의 무기나 아이템 생성</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>1. 팩토리 패턴의 종류</h2>
                    <div class="pattern-types">
                        <h3>1.1 Simple Factory (간단한 팩토리)</h3>
                        <p>가장 기본적인 형태의 팩토리 패턴으로, 객체 생성 로직을 하나의 클래스에 캡슐화합니다. 디자인 패턴이라기보다는 프로그래밍 관용구에 가깝습니다.</p>
                        
                        <h3>1.2 Factory Method (팩토리 메소드)</h3>
                        <p>객체를 생성하기 위한 인터페이스를 정의하고, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정하게 만듭니다. 클래스의 인스턴스를 만드는 일을 서브클래스에게 맡기는 패턴입니다.</p>
                        
                        <h3>1.3 Abstract Factory (추상 팩토리)</h3>
                        <p>인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체들을 구상 클래스를 지정하지 않고도 생성할 수 있게 합니다. 제품군을 생성하기 위한 인터페이스를 제공합니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>2. 왜 팩토리 패턴을 사용해야 하는가?</h2>
                    <div class="pattern-benefits">
                        <h3>2.1 객체 생성의 유연성</h3>
                        <p>객체 생성 로직을 한 곳에서 관리하여 코드의 중복을 방지하고, 새로운 타입의 객체 추가가 용이해집니다.</p>
                        
                        <h3>2.2 결합도 감소</h3>
                        <p>클라이언트 코드가 구체적인 클래스에 직접 의존하지 않아 코드의 결합도가 낮아지고 유지보수성이 향상됩니다.</p>
                        
                        <h3>2.3 확장성 향상</h3>
                        <p>새로운 제품 타입을 추가할 때 기존 코드를 수정하지 않고도 확장이 가능합니다.</p>
                        
                        <h3>2.4 일관성 유지</h3>
                        <p>객체 생성 과정을 표준화하여 일관된 방식으로 객체를 생성할 수 있습니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>3. 어떤 상황에서 사용해야 하는가?</h2>
                    <div class="pattern-use-cases">
                        <h3>3.1 객체 생성이 복잡한 경우</h3>
                        <p>객체 생성에 여러 단계나 조건이 필요한 경우, 이 로직을 팩토리 클래스에 캡슐화하여 관리합니다.</p>
                        
                        <h3>3.2 런타임에 객체 타입이 결정되는 경우</h3>
                        <p>프로그램 실행 중에 어떤 타입의 객체를 생성할지 결정해야 하는 경우에 적합합니다.</p>
                        
                        <h3>3.3 객체 생성에 의존성이 있는 경우</h3>
                        <p>객체 생성 시 다른 객체나 설정이 필요한 경우, 팩토리에서 이러한 의존성을 관리합니다.</p>
                        
                        <h3>3.4 객체 풀링이 필요한 경우</h3>
                        <p>객체를 재사용해야 하는 경우, 팩토리에서 객체 풀을 관리할 수 있습니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>4. 어떻게 구현하는가?</h2>
                    <p>Factory 패턴의 구현은 다양한 언어로 가능합니다. 아래 링크를 통해 각 언어별 구현 코드를 확인할 수 있습니다.</p>
                    
                    <div class="code-tabs">
                        <div class="code-language-buttons">
                            <a href="codes/factory_csharp.html" class="code-language-btn">C# 코드 보기</a>
                            <a href="codes/factory_cpp.html" class="code-language-btn">C++ 코드 보기</a>
                        </div>
                    </div>
                </div>

                <div class="content-section">
                    <h2>5. 팩토리 패턴의 장단점</h2>
                    <div class="pattern-pros-cons">
                        <h3>5.1 장점</h3>
                        <ul>
                            <li>
                                <strong>객체 생성 로직을 한 곳에서 관리하여 코드 중복 방지</strong>
                                <p>객체 생성과 관련된 모든 로직이 팩토리 클래스에 집중되어 있어 코드의 중복을 방지하고 유지보수가 용이합니다.</p>
                            </li>
                            <li>
                                <strong>새로운 제품 타입 추가가 용이</strong>
                                <p>새로운 제품 타입을 추가할 때 기존 코드를 수정하지 않고도 확장이 가능합니다.</p>
                            </li>
                            <li>
                                <strong>클라이언트 코드와 구체적인 클래스 간의 결합도 감소</strong>
                                <p>클라이언트는 구체적인 클래스가 아닌 인터페이스에 의존하게 되어 결합도가 낮아집니다.</p>
                            </li>
                            <li>
                                <strong>객체 생성 과정의 일관성 유지</strong>
                                <p>모든 객체가 동일한 방식으로 생성되므로 일관성이 보장됩니다.</p>
                            </li>
                        </ul>

                        <h3>5.2 단점</h3>
                        <ul>
                            <li>
                                <strong>클래스 수가 증가하여 코드가 복잡해질 수 있음</strong>
                                <p>팩토리 패턴을 적용하면 인터페이스, 구체 클래스, 팩토리 클래스 등 여러 클래스가 추가되어 코드가 복잡해질 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>간단한 객체 생성의 경우 오버엔지니어링이 될 수 있음</strong>
                                <p>단순한 객체 생성의 경우 팩토리 패턴을 적용하는 것이 불필요한 복잡성을 추가할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>팩토리 클래스가 모든 제품 타입을 알아야 함</strong>
                                <p>새로운 제품 타입이 추가될 때마다 팩토리 클래스도 수정해야 하는 경우가 발생할 수 있습니다.</p>
                            </li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>6. 주의사항 및 모범 사례</h2>
                    <div class="pattern-pros-cons">
                        <ul>
                            <li>
                                <strong>적절한 추상화 수준 선택</strong>
                                <p>팩토리 패턴을 적용할 때는 적절한 추상화 수준을 선택하는 것이 중요합니다. 너무 세분화하면 코드가 복잡해지고, 너무 일반화하면 유연성이 떨어질 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>팩토리 메서드와 추상 팩토리 패턴 구분</strong>
                                <p>팩토리 메서드는 단일 객체 생성에 집중하고, 추상 팩토리는 관련된 객체 그룹을 생성하는 데 사용됩니다. 상황에 맞는 패턴을 선택하세요.</p>
                            </li>
                            <li>
                                <strong>명확한 제품 인터페이스 설계</strong>
                                <p>제품 클래스들이 공유하는 인터페이스를 명확하게 설계하여 클라이언트 코드가 구체적인 클래스에 의존하지 않도록 합니다.</p>
                            </li>
                            <li>
                                <strong>매개변수화된 팩토리 메서드 고려</strong>
                                <p>다양한 종류의 제품을 생성해야 하는 경우, 팩토리 메서드에 매개변수를 전달하여 생성할 제품을 결정하는 방식을 고려할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>객체 재사용과 풀링 고려</strong>
                                <p>게임에서 자주 생성되고 파괴되는 객체(총알, 파티클 등)의 경우, 팩토리 패턴과 객체 풀 패턴을 결합하여 성능을 최적화할 수 있습니다.</p>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2024 GameDev PatternHub. All rights reserved.</p>
        </div>
    </footer>

    <script src="../js/main.js"></script>
</body>
</html>