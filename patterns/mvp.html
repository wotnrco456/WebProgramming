<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MVP 패턴 - GameDev PatternHub</title>
    <link rel="stylesheet" href="../css/common.css">
    <link rel="stylesheet" href="../css/layout.css">
    <link rel="stylesheet" href="../css/pattern-detail.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <header class="header">
        <nav class="nav-container">
            <div class="logo">
                <h1>GameDev PatternHub</h1>
            </div>
            <div class="nav-links">
                <a href="../index.html">홈</a>
                <a href="../patterns.html">패턴 목록</a>
                <a href="#">데모 게임</a>
                <a href="#">문서</a>
                <button id="theme-toggle" class="theme-toggle" aria-label="다크 모드 전환">
                    <i class="fas fa-moon"></i>
                </button>
            </div>
            <button class="mobile-menu-btn">
                <i class="fas fa-bars"></i>
            </button>
        </nav>
    </header>

    <main class="pattern-detail">
        <section class="pattern-header">
            <div class="container">
                <h1>MVP 패턴</h1>
                <div class="pattern-meta">
                    <span class="category">구조 패턴</span>
                    <span class="difficulty">난이도: ★★★☆☆</span>
                </div>
            </div>
        </section>

        <section class="pattern-content">
            <div class="container">
                <div class="content-section">
                    <h2>패턴 개요</h2>
                    <p>MVP(Model-View-Presenter) 패턴은 사용자 인터페이스와 비즈니스 로직을 분리하는 아키텍처 패턴입니다. 이 패턴은 코드의 모듈성을 향상시키고, 테스트 용이성을 높이며, 관심사의 분리(Separation of Concerns)를 촉진합니다. 게임 개발에서는 UI 관리, 데이터 표시, 사용자 입력 처리 등에 널리 사용됩니다.</p>
                    
                    <div class="pattern-benefits">
                        <h3>주요 장점</h3>
                        <ul>
                            <li>UI 로직과 비즈니스 로직의 명확한 분리</li>
                            <li>코드의 모듈성 및 재사용성 향상</li>
                            <li>단위 테스트 용이성 증가</li>
                            <li>UI 변경 시 비즈니스 로직 영향 최소화</li>
                            <li>다양한 플랫폼 및 화면에 대한 적응성 향상</li>
                        </ul>
                    </div>

                    <div class="pattern-use-cases">
                        <h3>사용 사례</h3>
                        <ul>
                            <li>게임 UI 시스템 (체력바, 스코어 보드, 인벤토리 등)</li>
                            <li>캐릭터 상태 표시 (체력, 마나, 경험치 등)</li>
                            <li>설정 화면 및 메뉴 시스템</li>
                            <li>게임 데이터 에디터 및 도구</li>
                            <li>복잡한 폼 및 입력 처리</li>
                            <li>멀티플랫폼 게임의 UI 일관성 유지</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>1. MVP 패턴의 기본 구성 요소</h2>
                    <div class="pattern-types">
                        <h3>1.1 Model(모델)</h3>
                        <p>애플리케이션의 데이터와 비즈니스 로직을 담당합니다. 데이터의 저장, 검색, 변환 등의 작업을 수행하며, View나 Presenter에 대한 정보를 가지지 않습니다. 모델은 데이터의 관리 및 조작에 관한 비즈니스 규칙을 포함합니다.</p>
                        
                        <h3>1.2 View(뷰)</h3>
                        <p>사용자에게 정보를 표시하고 사용자의 입력을 받는 역할을 합니다. 게임에서는 UI 요소(버튼, 슬라이더, 텍스트 등)가 View에 해당합니다. 뷰는 사용자 인터페이스를 담당하며, 비즈니스 로직을 포함하지 않습니다.</p>
                        
                        <h3>1.3 Presenter(프리젠터)</h3>
                        <p>View와 Model 사이의 중재자 역할을 합니다. View의 입력을 받아 Model을 조작하고, Model의 변경 사항을 View에 반영합니다. 프리젠터는 뷰와 모델 간의 상호작용을 조정하고, 뷰에 표시될 데이터를 가공합니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>2. 왜 MVP 패턴을 사용해야 하는가?</h2>
                    <div class="pattern-benefits">
                        <h3>2.1 관심사의 분리</h3>
                        <p>MVP 패턴은 데이터(Model), 표현(View), 논리(Presenter)를 명확히 분리하여 각 구성 요소가 자신의 책임에만 집중할 수 있게 합니다. 이는 코드의 가독성과 유지보수성을 크게 향상시킵니다.</p>
                        
                        <h3>2.2 테스트 용이성</h3>
                        <p>UI와 비즈니스 로직이 분리되어 있어 Presenter와 Model은 View 없이도 독립적으로 테스트할 수 있습니다. 이는, 특히 Unity와 같은 게임 엔진 환경에서 단위 테스트를 더 쉽게 만듭니다.</p>
                        
                        <h3>2.3 코드 재사용성</h3>
                        <p>동일한 Model을 다양한 View와 함께 사용할 수 있으며, 다양한 플랫폼에서 UI만 변경하면서 동일한 비즈니스 로직을 유지할 수 있습니다.</p>
                        
                        <h3>2.4 변경 관리 용이성</h3>
                        <p>UI 디자인이 변경되어도 비즈니스 로직에는 영향을 주지 않으며, 비즈니스 로직이 변경되어도 UI 코드를 수정할 필요가 없습니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>3. 어떤 상황에서 사용해야 하는가?</h2>
                    <div class="pattern-use-cases">
                        <h3>3.1 복잡한 UI가 있는 게임</h3>
                        <p>인벤토리 시스템, 캐릭터 상태 창, 퀘스트 로그 등 복잡한 UI 요소가 많은 게임에서 MVP 패턴은 코드를 체계적으로 관리하는 데 도움이 됩니다.</p>
                        
                        <h3>3.2 다양한 플랫폼 지원이 필요한 경우</h3>
                        <p>PC, 모바일, 콘솔 등 다양한 플랫폼에서 실행되는 게임의 경우, MVP 패턴을 사용하면 플랫폼별로 View만 변경하면서 동일한 비즈니스 로직을 유지할 수 있습니다.</p>
                        
                        <h3>3.3 팀 협업이 필요한 큰 프로젝트</h3>
                        <p>UI 디자이너, 프로그래머, 게임 디자이너 등이 함께 작업하는 프로젝트에서 MVP 패턴은 역할과 책임을 명확히 분리하여 협업을 용이하게 합니다.</p>
                        
                        <h3>3.4 테스트 주도 개발(TDD)을 적용하는 경우</h3>
                        <p>테스트 주도 개발 방법론을 사용하는 프로젝트에서 MVP 패턴은 UI와 분리된 비즈니스 로직에 대한 단위 테스트를 쉽게 작성할 수 있게 합니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>4. 어떻게 구현하는가?</h2>
                    <p>MVP 패턴의 구현은 다양한 언어로 가능합니다. 아래 링크를 통해 각 언어별 구현 코드를 확인할 수 있습니다.</p>
                    
                    <div class="code-tabs">
                        <div class="code-language-buttons">
                            <a href="codes/mvp_csharp.html" class="code-language-btn">C# 코드 보기 <i class="fas fa-code"></i></a>
                            <a href="codes/mvp_cpp.html" class="code-language-btn">C++ 코드 보기 <i class="fas fa-code"></i></a>
                        </div>
                    </div>
                </div>

                <div class="content-section">
                    <h2>5. MVP 패턴의 장단점</h2>
                    <div class="pattern-pros-cons">
                        <h3>5.1 장점</h3>
                        <ul>
                            <li>
                                <strong>관심사의 분리</strong>
                                <p>UI, 데이터, 로직이 명확히 분리되어 코드의 가독성과 유지보수성이 향상됩니다.</p>
                            </li>
                            <li>
                                <strong>테스트 용이성</strong>
                                <p>Presenter와 Model은 View 없이도 독립적으로 테스트할 수 있어 단위 테스트 작성이 쉬워집니다.</p>
                            </li>
                            <li>
                                <strong>코드 재사용성</strong>
                                <p>동일한 Model과 Presenter를 다양한 View와 함께 사용할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>유연성</strong>
                                <p>각 구성 요소를 독립적으로 수정하고 확장할 수 있어 요구사항 변경에 유연하게 대응할 수 있습니다.</p>
                            </li>
                        </ul>

                        <h3>5.2 단점</h3>
                        <ul>
                            <li>
                                <strong>코드량 증가</strong>
                                <p>단순한 기능에도 세 가지 구성 요소를 모두 구현해야 하므로 코드량이 늘어날 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>러닝 커브</strong>
                                <p>패턴을 처음 접하는 개발자에게는 이해하고 구현하기 어려울 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>Presenter의 복잡성</strong>
                                <p>복잡한 UI 로직은 Presenter에 많은 코드가 집중되어 'Massive Presenter' 문제가 발생할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>오버엔지니어링 가능성</strong>
                                <p>간단한 UI나 작은 프로젝트에서는 MVP 패턴이 불필요한 복잡성을 추가할 수 있습니다.</p>
                            </li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>6. MVP 패턴의 변형</h2>
                    <div class="pattern-pros-cons">
                        <h3>6.1 Passive View</h3>
                        <p>이 변형에서는 View가 매우 수동적이며 거의 모든 로직이 Presenter에 집중됩니다. View는 단순히 사용자 입력을 Presenter에 전달하고 Presenter의 지시에 따라 화면을 갱신합니다.</p>
                        
                        <h3>6.2 Supervising Controller</h3>
                        <p>이 변형에서는 View가 더 많은 책임을 가지며, 단순한 데이터 바인딩은 View가 직접 처리하고 복잡한 UI 로직만 Presenter가 담당합니다.</p>
                        
                        <h3>6.3 MVP와 MVVM의 혼합</h3>
                        <p>Unity와 같은 게임 엔진에서는 종종 MVP와 MVVM(Model-View-ViewModel) 패턴의 요소를 혼합하여 사용합니다. 데이터 바인딩 메커니즘을 활용하면서도 Presenter의 중재자 역할을 유지합니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>7. 게임 개발에서의 MVP 패턴 응용</h2>
                    <div class="pattern-pros-cons">
                        <h3>7.1 체력 시스템</h3>
                        <p>Model은 플레이어의 체력 데이터를 관리하고, View는 체력바 UI를 표시하며, Presenter는 데미지 이벤트를 처리하여 Model을 갱신하고 View를 업데이트합니다.</p>
                        
                        <h3>7.2 인벤토리 시스템</h3>
                        <p>Model은 아이템 데이터와 소지품 목록을 관리하고, View는 인벤토리 UI를 표시하며, Presenter는 아이템 획득, 사용, 버리기 등의 작업을 처리합니다.</p>
                        
                        <h3>7.3 대화 시스템</h3>
                        <p>Model은 NPC 대화 데이터를 관리하고, View는 대화창과 선택지 UI를 표시하며, Presenter는 대화 진행과 플레이어 선택에 따른 분기를 처리합니다.</p>
                        
                        <h3>7.4 게임 설정</h3>
                        <p>Model은 게임 설정 데이터를 관리하고, View는 설정 화면 UI를 표시하며, Presenter는 설정 변경 작업을 처리하고 저장합니다.</p>
                    </div>
                </div>
                
                <div class="navigation-buttons">
                    <a href="../patterns.html" class="back-button"><i class="fas fa-arrow-left"></i> 패턴 목록으로 돌아가기</a>
                    <a href="codes/mvp_csharp.html" class="next-button">C# 코드 예제 보기 <i class="fas fa-arrow-right"></i></a>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2025 GameDev PatternHub. All rights reserved.</p>
        </div>
    </footer>

    <script src="../js/main.js"></script>
</body>
</html>