<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MVP 패턴 - GameDev PatternHub</title>
    <link rel="stylesheet" href="../css/common.css">
    <link rel="stylesheet" href="../css/layout.css">
    <link rel="stylesheet" href="../css/pattern-detail.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js"></script>
</head>
<body>
    <header class="header">
        <nav class="nav-container">
            <div class="logo">
                <h1>GameDev PatternHub</h1>
            </div>
            <div class="nav-links">
                <a href="../index.html">홈</a>
                <a href="../patterns.html">패턴 목록</a>
                <a href="#">데모 게임</a>
                <a href="#">문서</a>
            </div>
            <button class="mobile-menu-btn">
                <i class="fas fa-bars"></i>
            </button>
        </nav>
    </header>

    <main class="pattern-detail">
        <section class="pattern-header">
            <div class="container">
                <h1>MVP 패턴</h1>
                <div class="pattern-meta">
                    <span class="category">구조 패턴</span>
                    <span class="difficulty">난이도: ★★★☆☆</span>
                </div>
            </div>
        </section>

        <section class="pattern-content">
            <div class="container">
                <div class="content-section">
                    <h2>패턴 개요</h2>
                    <p>MVP(Model-View-Presenter) 패턴은 사용자 인터페이스와 비즈니스 로직을 분리하는 아키텍처 패턴입니다. 이 패턴은 코드의 모듈성을 향상시키고, 테스트 용이성을 높이며, 관심사의 분리(Separation of Concerns)를 촉진합니다. 게임 개발에서는 UI 관리, 데이터 표시, 사용자 입력 처리 등에 널리 사용됩니다.</p>
                    
                    <div class="pattern-benefits">
                        <h3>주요 장점</h3>
                        <ul>
                            <li>UI 로직과 비즈니스 로직의 명확한 분리</li>
                            <li>코드의 모듈성 및 재사용성 향상</li>
                            <li>단위 테스트 용이성 증가</li>
                            <li>UI 변경 시 비즈니스 로직 영향 최소화</li>
                            <li>다양한 플랫폼 및 화면에 대한 적응성 향상</li>
                        </ul>
                    </div>

                    <div class="pattern-use-cases">
                        <h3>사용 사례</h3>
                        <ul>
                            <li>게임 UI 시스템 (체력바, 스코어 보드, 인벤토리 등)</li>
                            <li>캐릭터 상태 표시 (체력, 마나, 경험치 등)</li>
                            <li>설정 화면 및 메뉴 시스템</li>
                            <li>게임 데이터 에디터 및 도구</li>
                            <li>복잡한 폼 및 입력 처리</li>
                            <li>멀티플랫폼 게임의 UI 일관성 유지</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>1. MVP 패턴의 기본 구성 요소</h2>
                    <p>MVP 패턴은 다음과 같은 세 가지 주요 구성 요소로 이루어집니다:</p>
                    <div class="pattern-pros-cons">
                        <ul>
                            <li><strong>Model(모델)</strong> - 애플리케이션의 데이터와 비즈니스 로직을 담당합니다. 데이터의 저장, 검색, 변환 등의 작업을 수행하며, View나 Presenter에 대한 정보를 가지지 않습니다.</li>
                            <li><strong>View(뷰)</strong> - 사용자에게 정보를 표시하고 사용자의 입력을 받는 역할을 합니다. 게임에서는 UI 요소(버튼, 슬라이더, 텍스트 등)가 View에 해당합니다.</li>
                            <li><strong>Presenter(프리젠터)</strong> - View와 Model 사이의 중재자 역할을 합니다. View의 입력을 받아 Model을 조작하고, Model의 변경 사항을 View에 반영합니다.</li>
                        </ul>
                    </div>
                    <p>이러한 구성 요소들 간의 상호작용을 통해 UI와 비즈니스 로직이 분리되어 유지보수성과 테스트 용이성이 향상됩니다.</p>
                </div>

                <div class="content-section">
                    <h2>2. 왜 MVP 패턴을 사용해야 하는가?</h2>
                    <div class="pattern-benefits">
                        <h3>2.1 관심사의 분리</h3>
                        <p>MVP 패턴은 데이터(Model), 표현(View), 논리(Presenter)를 명확히 분리하여 각 구성 요소가 자신의 책임에만 집중할 수 있게 합니다. 이는 코드의 가독성과 유지보수성을 크게 향상시킵니다.</p>
                        
                        <h3>2.2 테스트 용이성</h3>
                        <p>UI와 비즈니스 로직이 분리되어 있어 Presenter와 Model은 View 없이도 독립적으로 테스트할 수 있습니다. 이는, 특히 Unity와 같은 게임 엔진 환경에서 단위 테스트를 더 쉽게 만듭니다.</p>
                        
                        <h3>2.3 코드 재사용성</h3>
                        <p>동일한 Model을 다양한 View와 함께 사용할 수 있으며, 다양한 플랫폼에서 UI만 변경하면서 동일한 비즈니스 로직을 유지할 수 있습니다.</p>
                        
                        <h3>2.4 변경 관리 용이성</h3>
                        <p>UI 디자인이 변경되어도 비즈니스 로직에는 영향을 주지 않으며, 비즈니스 로직이 변경되어도 UI 코드를 수정할 필요가 없습니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>3. 어떤 상황에서 사용해야 하는가?</h2>
                    <div class="pattern-use-cases">
                        <h3>3.1 복잡한 UI가 있는 게임</h3>
                        <p>인벤토리 시스템, 캐릭터 상태 창, 퀘스트 로그 등 복잡한 UI 요소가 많은 게임에서 MVP 패턴은 코드를 체계적으로 관리하는 데 도움이 됩니다.</p>
                        
                        <h3>3.2 다양한 플랫폼 지원이 필요한 경우</h3>
                        <p>PC, 모바일, 콘솔 등 다양한 플랫폼에서 실행되는 게임의 경우, MVP 패턴을 사용하면 플랫폼별로 View만 변경하면서 동일한 비즈니스 로직을 유지할 수 있습니다.</p>
                        
                        <h3>3.3 팀 협업이 필요한 큰 프로젝트</h3>
                        <p>UI 디자이너, 프로그래머, 게임 디자이너 등이 함께 작업하는 프로젝트에서 MVP 패턴은 역할과 책임을 명확히 분리하여 협업을 용이하게 합니다.</p>
                        
                        <h3>3.4 테스트 주도 개발(TDD)을 적용하는 경우</h3>
                        <p>테스트 주도 개발 방법론을 사용하는 프로젝트에서 MVP 패턴은 UI와 분리된 비즈니스 로직에 대한 단위 테스트를 쉽게 작성할 수 있게 합니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>4. 어떻게 구현하는가?</h2>
                    <div class="code-tabs">
                        <div class="tab-buttons">
                            <button class="tab-btn active" data-lang="csharp">C#</button>
                            <button class="tab-btn" data-lang="cpp">C++</button>
                        </div>
                        
                        <div class="tab-content">
                            <div class="code-block active" id="csharp-code">
                                <h3>4.1 기본 구조</h3>
                                <pre><code class="language-csharp">using System;

namespace MVPPattern
{
    // Model: 데이터와 비즈니스 로직을 관리
    public class HealthModel
    {
        // 상태 변화 알림을 위한 이벤트
        public event EventHandler HealthChanged;

        // 상수 정의
        private const int MinHealth = 0;
        private const int MaxHealth = 100;
        
        // 데이터
        private int currentHealth;

        // 프로퍼티 - 값이 변경될 때 이벤트 발생
        public int CurrentHealth
        {
            get => currentHealth;
            set
            {
                currentHealth = Math.Clamp(value, MinHealth, MaxHealth);
                OnHealthChanged(EventArgs.Empty); // 상태 변화 알림
            }
        }

        public int MinimumHealth => MinHealth;
        public int MaximumHealth => MaxHealth;

        // 생성자
        public HealthModel(int initialHealth = 100)
        {
            CurrentHealth = initialHealth;
        }

        // 비즈니스 로직 메서드
        public void Increment(int amount)
        {
            CurrentHealth += amount;
        }

        public void Decrement(int amount)
        {
            CurrentHealth -= amount;
        }

        public void Restore()
        {
            CurrentHealth = MaxHealth;
        }

        // 이벤트 호출 메서드
        protected virtual void OnHealthChanged(EventArgs e)
        {
            HealthChanged?.Invoke(this, e);
        }
    }

    // View 인터페이스: UI 표시 방법 정의
    public interface IHealthView
    {
        void UpdateHealthDisplay(int health, int maxHealth);
        void SetDamageHandler(Action<int> damageAction);
        void SetHealHandler(Action<int> healAction);
        void SetResetHandler(Action resetAction);
    }

    // Presenter: View와 Model 사이의 중재자
    public class HealthPresenter
    {
        private readonly HealthModel model;
        private readonly IHealthView view;

        // 생성자
        public HealthPresenter(HealthModel model, IHealthView view)
        {
            this.model = model;
            this.view = view;

            // Model의 이벤트에 구독
            model.HealthChanged += OnHealthChanged;

            // View의 이벤트 핸들러 등록
            view.SetDamageHandler(OnDamage);
            view.SetHealHandler(OnHeal);
            view.SetResetHandler(OnReset);

            // 초기 UI 업데이트
            UpdateView();
        }

        // Model 이벤트 처리
        private void OnHealthChanged(object sender, EventArgs e)
        {
            UpdateView();
        }

        // View 이벤트 처리
        private void OnDamage(int amount)
        {
            model.Decrement(amount);
        }

        private void OnHeal(int amount)
        {
            model.Increment(amount);
        }

        private void OnReset()
        {
            model.Restore();
        }

        // View 업데이트
        private void UpdateView()
        {
            view.UpdateHealthDisplay(model.CurrentHealth, model.MaximumHealth);
        }

        // 리소스 해제
        public void Dispose()
        {
            model.HealthChanged -= OnHealthChanged;
        }
    }
}</code></pre>

                                <h3>4.2 사용 예시</h3>
                                <pre><code class="language-csharp">using System;

namespace MVPPattern.Example
{
    // 콘솔 UI 구현
    public class ConsoleHealthView : IHealthView
    {
        private Action<int> damageAction;
        private Action<int> healAction;
        private Action resetAction;
        private readonly int damageAmount = 10;
        private readonly int healAmount = 5;

        // IHealthView 인터페이스 구현
        public void UpdateHealthDisplay(int health, int maxHealth)
        {
            Console.WriteLine("\n========== Health Status ==========");
            Console.WriteLine($"Health: {health}/{maxHealth}");

            // 체력바 시각화
            int barLength = 20;
            int filledLength = (int)((float)health / maxHealth * barLength);

            Console.Write("[");
            for (int i = 0; i < barLength; i++)
            {
                if (i < filledLength)
                    Console.Write("#");
                else
                    Console.Write("-");
            }
            Console.WriteLine("]\n");

            // 메뉴 표시
            Console.WriteLine($"1. Take Damage ({damageAmount})");
            Console.WriteLine($"2. Heal ({healAmount})");
            Console.WriteLine("3. Reset Health");
            Console.WriteLine("0. Exit");
        }

        public void SetDamageHandler(Action<int> damageAction)
        {
            this.damageAction = damageAction;
        }

        public void SetHealHandler(Action<int> healAction)
        {
            this.healAction = healAction;
        }

        public void SetResetHandler(Action resetAction)
        {
            this.resetAction = resetAction;
        }

        // 사용자 입력 처리
        public bool ProcessUserInput()
        {
            Console.Write("\nSelect an option: ");
            string input = Console.ReadLine();

            if (int.TryParse(input, out int choice))
            {
                switch (choice)
                {
                    case 1:
                        damageAction?.Invoke(damageAmount);
                        return true;
                    case 2:
                        healAction?.Invoke(healAmount);
                        return true;
                    case 3:
                        resetAction?.Invoke();
                        return true;
                    case 0:
                        return false;
                    default:
                        Console.WriteLine("Invalid option. Please try again.");
                        return true;
                }
            }
            else
            {
                Console.WriteLine("Invalid input. Please enter a number.");
                return true;
            }
        }
    }

    // 예제 프로그램
    public class Program
    {
        public static void Main(string[] args)
        {
            Console.WriteLine("MVP Pattern - Health Management System");
            Console.WriteLine("------------------------------------");

            // MVP 구성 요소 생성
            HealthModel model = new HealthModel(100);
            ConsoleHealthView view = new ConsoleHealthView();
            HealthPresenter presenter = new HealthPresenter(model, view);

            // 프로그램 실행
            bool running = true;
            while (running)
            {
                running = view.ProcessUserInput();
            }

            // 종료
            presenter.Dispose();
            Console.WriteLine("\nProgram terminated. Thank you for using the Health Management System.");
        }
    }
}</code></pre>
                            </div>

                            <div class="code-block" id="cpp-code">
                                <h3>4.1 기본 구조</h3>
                                <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;
#include &lt;algorithm&gt;
#include &lt;memory&gt;

namespace MVPPattern {

    // Model: 데이터와 비즈니스 로직을 관리
    class HealthModel {
    private:
        static const int MIN_HEALTH = 0;
        static const int MAX_HEALTH = 100;
        int currentHealth;
        
        // C++에서는 이벤트 대신 이벤트리스너 패턴 사용
        std::vector<std::function<void(int)>> healthChangedListeners;
        
    public:
        HealthModel(int initialHealth = 100) {
            currentHealth = std::clamp(initialHealth, MIN_HEALTH, MAX_HEALTH);
        }
        
        // 프로퍼티 게터
        int GetCurrentHealth() const { return currentHealth; }
        int GetMinimumHealth() const { return MIN_HEALTH; }
        int GetMaximumHealth() const { return MAX_HEALTH; }
        
        // 프로퍼티 세터 - 값이 변경될 때 이벤트 발생
        void SetCurrentHealth(int value) {
            currentHealth = std::clamp(value, MIN_HEALTH, MAX_HEALTH);
            NotifyHealthChanged(); // 상태 변화 알림
        }
        
        // 이벤트 구독 및 구독 취소 기능
        void AddHealthChangedListener(const std::function<void(int)>& listener) {
            healthChangedListeners.push_back(listener);
        }
        
        void RemoveHealthChangedListener(const std::function<void(int)>& listener) {
            // 실제 구현에서는 더 복잡한 제거 로직이 필요함
            // 여기서는 간단히 구현
            auto it = std::find_if(healthChangedListeners.begin(), healthChangedListeners.end(),
                [&listener](const auto& l) { 
                    // 이걸 실제로 실행할 수는 없지만, 개념을 보여주기 위한 코드
                    return &l == &listener; 
                });
            
            if (it != healthChangedListeners.end()) {
                healthChangedListeners.erase(it);
            }
        }
        
        // 이벤트 발생 함수
        void NotifyHealthChanged() {
            for (const auto& listener : healthChangedListeners) {
                listener(currentHealth);
            }
        }
        
        // 비즈니스 로직 메서드
        void Increment(int amount) {
            SetCurrentHealth(currentHealth + amount);
        }
        
        void Decrement(int amount) {
            SetCurrentHealth(currentHealth - amount);
        }
        
        void Restore() {
            SetCurrentHealth(MAX_HEALTH);
        }
    };
    
    // View 인터페이스: UI 표시 방법 정의
    class IHealthView {
    public:
        virtual ~IHealthView() = default;
        
        virtual void UpdateHealthDisplay(int health, int maxHealth) = 0;
        virtual void SetDamageHandler(const std::function<void(int)>& callback) = 0;
        virtual void SetHealHandler(const std::function<void(int)>& callback) = 0;
        virtual void SetResetHandler(const std::function<void()>& callback) = 0;
    };
    
    // Presenter: View와 Model 사이의 중재자
    class HealthPresenter {
    private:
        HealthModel& model;
        IHealthView& view;
        std::function<void(int)> healthChangedListener;
        
    public:
        HealthPresenter(HealthModel& model, IHealthView& view) : model(model), view(view) {
            // Model의 이벤트에 구독
            healthChangedListener = [this](int health) { this->OnHealthChanged(health); };
            model.AddHealthChangedListener(healthChangedListener);
            
            // View의 이벤트 핸들러 등록
            view.SetDamageHandler([this](int amount) { this->OnDamage(amount); });
            view.SetHealHandler([this](int amount) { this->OnHeal(amount); });
            view.SetResetHandler([this]() { this->OnReset(); });
            
            // 초기 UI 업데이트
            UpdateView();
        }
        
        // 소명자 - 리소스 해제
        ~HealthPresenter() {
            model.RemoveHealthChangedListener(healthChangedListener);
        }
        
        // Model 이벤트 처리
        void OnHealthChanged(int health) {
            UpdateView();
        }
        
        // View 이벤트 처리
        void OnDamage(int amount) {
            model.Decrement(amount);
        }
        
        void OnHeal(int amount) {
            model.Increment(amount);
        }
        
        void OnReset() {
            model.Restore();
        }
        
        // View 업데이트
        void UpdateView() {
            view.UpdateHealthDisplay(model.GetCurrentHealth(), model.GetMaximumHealth());
        }
    };
}</code></pre>

                                <h3>4.2 사용 예시</h3>
                                <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
#include &lt;limits&gt;

// 위에서 정의한 클래스들 포함 (HealthModel, IHealthView, HealthPresenter)

namespace MVPPattern {

    // 콘솔 기반 View 구현
    class ConsoleHealthView : public IHealthView {
    private:
        std::function<void(int)> damageHandler;
        std::function<void(int)> healHandler;
        std::function<void()> resetHandler;
        const int damageAmount = 10;
        const int healAmount = 5;
        
    public:
        // IHealthView 인터페이스 구현
        void UpdateHealthDisplay(int health, int maxHealth) override {
            std::cout << "\n==========================" << std::endl;
            std::cout << "Health Management System" << std::endl;
            std::cout << "==========================" << std::endl;
            std::cout << "Health: " << health << "/" << maxHealth << std::endl;
            
            // 체력바 시각화
            const int barLength = 20;
            const int filledLength = static_cast<int>((static_cast<float>(health) / maxHealth) * barLength);
            
            std::cout << "[";
            for (int i = 0; i < barLength; ++i) {
                if (i < filledLength) {
                    std::cout << "#";
                } else {
                    std::cout << "-";
                }
            }
            std::cout << "]" << std::endl;
            
            // 메뉴 표시
            std::cout << "\nOptions:" << std::endl;
            std::cout << "1. Take Damage (" << damageAmount << ")" << std::endl;
            std::cout << "2. Heal (" << healAmount << ")" << std::endl;
            std::cout << "3. Reset Health" << std::endl;
            std::cout << "0. Exit" << std::endl;
        }
        
        void SetDamageHandler(const std::function<void(int)>& callback) override {
            damageHandler = callback;
        }
        
        void SetHealHandler(const std::function<void(int)>& callback) override {
            healHandler = callback;
        }
        
        void SetResetHandler(const std::function<void()>& callback) override {
            resetHandler = callback;
        }
        
        // 사용자 입력 처리
        bool ProcessInput() {
            std::cout << "\nEnter your choice: ";
            int choice;
            std::cin >> choice;
            
            // 입력 오류 처리
            if (std::cin.fail()) {
                std::cin.clear(); // 오류 플래그 초기화
                std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // 버퍼 비우기
                std::cout << "Invalid input. Please enter a number." << std::endl;
                return true;
            }
            
            switch (choice) {
                case 1:
                    if (damageHandler) {
                        damageHandler(damageAmount);
                    }
                    return true;
                case 2:
                    if (healHandler) {
                        healHandler(healAmount);
                    }
                    return true;
                case 3:
                    if (resetHandler) {
                        resetHandler();
                    }
                    return true;
                case 0:
                    return false; // 프로그램 종료
                default:
                    std::cout << "Invalid option. Please try again." << std::endl;
                    return true;
            }
        }
    };
}

// 메인 프로그램
int main() {
    using namespace MVPPattern;
    
    std::cout << "MVP Pattern Demo - Health Management System" << std::endl;
    
    // 모델, 뷰, 프리젠터 객체 생성
    HealthModel model(100);
    ConsoleHealthView view;
    
    // 프리젠터는 스코프를 위해 블록에서 생성
    {
        HealthPresenter presenter(model, view);
        
        // 애플리케이션 루프
        bool running = true;
        while (running) {
            running = view.ProcessInput();
        }
        
        // presenter는 스코프를 나갈 때 자동으로 소명자 호출
    }
    
    std::cout << "\nThank you for using the Health Management System. Goodbye!" << std::endl;
    return 0;
}</code></pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="content-section">
                    <h2>5. MVP 패턴의 장단점</h2>
                    <div class="pattern-pros-cons">
                        <h3>5.1 장점</h3>
                        <ul>
                            <li>
                                <strong>관심사의 분리</strong>
                                <p>UI, 데이터, 로직이 명확히 분리되어 코드의 가독성과 유지보수성이 향상됩니다.</p>
                            </li>
                            <li>
                                <strong>테스트 용이성</strong>
                                <p>Presenter와 Model은 View 없이도 독립적으로 테스트할 수 있어 단위 테스트 작성이 쉬워집니다.</p>
                            </li>
                            <li>
                                <strong>코드 재사용성</strong>
                                <p>동일한 Model과 Presenter를 다양한 View와 함께 사용할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>유연성</strong>
                                <p>각 구성 요소를 독립적으로 수정하고 확장할 수 있어 요구사항 변경에 유연하게 대응할 수 있습니다.</p>
                            </li>
                        </ul>

                        <h3>5.2 단점</h3>
                        <ul>
                            <li>
                                <strong>코드량 증가</strong>
                                <p>단순한 기능에도 세 가지 구성 요소를 모두 구현해야 하므로 코드량이 늘어날 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>러닝 커브</strong>
                                <p>패턴을 처음 접하는 개발자에게는 이해하고 구현하기 어려울 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>Presenter의 복잡성</strong>
                                <p>복잡한 UI 로직은 Presenter에 많은 코드가 집중되어 'Massive Presenter' 문제가 발생할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>오버엔지니어링 가능성</strong>
                                <p>간단한 UI나 작은 프로젝트에서는 MVP 패턴이 불필요한 복잡성을 추가할 수 있습니다.</p>
                            </li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>6. MVP 패턴의 변형</h2>
                    <div class="pattern-pros-cons">
                        <h3>6.1 Passive View</h3>
                        <p>이 변형에서는 View가 매우 수동적이며 거의 모든 로직이 Presenter에 집중됩니다. View는 단순히 사용자 입력을 Presenter에 전달하고 Presenter의 지시에 따라 화면을 갱신합니다.</p>
                        
                        <h3>6.2 Supervising Controller</h3>
                        <p>이 변형에서는 View가 더 많은 책임을 가지며, 단순한 데이터 바인딩은 View가 직접 처리하고 복잡한 UI 로직만 Presenter가 담당합니다.</p>
                        
                        <h3>6.3 MVP와 MVVM의 혼합</h3>
                        <p>Unity와 같은 게임 엔진에서는 종종 MVP와 MVVM(Model-View-ViewModel) 패턴의 요소를 혼합하여 사용합니다. 데이터 바인딩 메커니즘을 활용하면서도 Presenter의 중재자 역할을 유지합니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>7. 게임 개발에서의 MVP 패턴 응용</h2>
                    <div class="pattern-pros-cons">
                        <h3>7.1 체력 시스템</h3>
                        <p>Model은 플레이어의 체력 데이터를 관리하고, View는 체력바 UI를 표시하며, Presenter는 데미지 이벤트를 처리하여 Model을 갱신하고 View를 업데이트합니다.</p>
                        
                        <h3>7.2 인벤토리 시스템</h3>
                        <p>Model은 아이템 데이터와 소지품 목록을 관리하고, View는 인벤토리 UI를 표시하며, Presenter는 아이템 획득, 사용, 버리기 등의 작업을 처리합니다.</p>
                        
                        <h3>7.3 대화 시스템</h3>
                        <p>Model은 NPC 대화 데이터를 관리하고, View는 대화창과 선택지 UI를 표시하며, Presenter는 대화 진행과 플레이어 선택에 따른 분기를 처리합니다.</p>
                        
                        <h3>7.4 게임 설정</h3>
                        <p>Model은 게임 설정 데이터를 관리하고, View는 설정 화면 UI를 표시하며, Presenter는 설정 변경 작업을 처리하고 저장합니다.</p>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2024 GameDev PatternHub. All rights reserved.</p>
        </div>
    </footer>

    <script src="../js/main.js"></script>
    <script>
        // 코드 하이라이팅 초기화
        document.addEventListener('DOMContentLoaded', (event) => {
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightBlock(block);
            });
        });

        // 언어 탭 전환
        const tabButtons = document.querySelectorAll('.tab-btn');
        const codeBlocks = document.querySelectorAll('.code-block');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const lang = button.getAttribute('data-lang');
                
                // 버튼 활성화 상태 변경
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                // 코드 블록 표시/숨김
                codeBlocks.forEach(block => {
                    block.classList.remove('active');
                    if (block.id === `${lang}-code`) {
                        block.classList.add('active');
                    }
                });
            });
        });
    </script>
</body>
</html>