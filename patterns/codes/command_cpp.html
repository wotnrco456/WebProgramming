<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Command 패턴 - C++ 코드</title>
    <link rel="stylesheet" href="../../css/common.css">
    <link rel="stylesheet" href="../../css/layout.css">
    <link rel="stylesheet" href="../../css/pattern-detail.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js"></script>
</head>
<body>
    <header class="header">
        <nav class="nav-container">
            <div class="logo">
                <h1>GameDev PatternHub</h1>
            </div>
            <div class="nav-links">
                <a href="../../index.html">홈</a>
                <a href="../../patterns.html">패턴 목록</a>
                <a href="#">데모 게임</a>
                <a href="#">문서</a>
            </div>
            <button class="mobile-menu-btn">
                <i class="fas fa-bars"></i>
            </button>
        </nav>
    </header>

    <main class="pattern-detail">
        <section class="pattern-header">
            <div class="container">
                <h1>Command 패턴 - C++ 코드</h1>
                <div class="pattern-meta">
                    <span class="category">행동 패턴</span>
                    <span class="language">C++ 구현</span>
                </div>
            </div>
        </section>

        <section class="pattern-content">
            <div class="container">
                <div class="content-section">
                    <h2>Command 패턴의 C++ 구현</h2>
                    <p>Command 패턴의 C++ 구현 코드와 사용 예시입니다.</p>
                    
                    <div class="code-section">
                        <h3>4.1 기본 구조</h3>
                        <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;

// Command 인터페이스
class Command {
public:
    virtual ~Command() = default;
    virtual void execute() = 0;
    virtual void undo() = 0;
};

// Receiver - 명령이 실행될 대상
class Robot {
private:
    int x = 0;
    int y = 0;

public:
    void move(int deltaX, int deltaY) {
        x += deltaX;
        y += deltaY;
        std::cout &lt;&lt; "로봇이 (" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ") 위치로 이동했습니다." &lt;&lt; std::endl;
    }
};

// Concrete Command - 로봇 이동 명령
class MoveCommand : public Command {
private:
    Robot&amp; robot;
    int deltaX;
    int deltaY;

public:
    MoveCommand(Robot&amp; robot, int deltaX, int deltaY)
        : robot(robot), deltaX(deltaX), deltaY(deltaY) {}

    void execute() override {
        robot.move(deltaX, deltaY);
    }

    void undo() override {
        robot.move(-deltaX, -deltaY);
    }
};

// Invoker - 명령 실행을 요청하는 클래스
class CommandInvoker {
private:
    std::stack&lt;std::shared_ptr&lt;Command&gt;&gt; undoStack;
    std::stack&lt;std::shared_ptr&lt;Command&gt;&gt; redoStack;

public:
    void executeCommand(std::shared_ptr&lt;Command&gt; command) {
        command->execute();
        undoStack.push(command);
        
        // 새 명령 실행 시 redo 스택 비우기
        while (!redoStack.empty()) {
            redoStack.pop();
        }
    }

    void undo() {
        if (!undoStack.empty()) {
            auto command = undoStack.top();
            undoStack.pop();
            command->undo();
            redoStack.push(command);
        } else {
            std::cout &lt;&lt; "취소할 명령이 없습니다." &lt;&lt; std::endl;
        }
    }

    void redo() {
        if (!redoStack.empty()) {
            auto command = redoStack.top();
            redoStack.pop();
            command->execute();
            undoStack.push(command);
        } else {
            std::cout &lt;&lt; "재실행할 명령이 없습니다." &lt;&lt; std::endl;
        }
    }
};</code></pre>

                        <h3>4.2 사용 예시</h3>
                        <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
    // Receiver 생성
    Robot robot;
    
    // Invoker 생성
    CommandInvoker invoker;
    
    // 명령 생성 및 실행
    auto moveRight = std::make_shared&lt;MoveCommand&gt;(robot, 1, 0);
    invoker.executeCommand(moveRight);
    
    auto moveUp = std::make_shared&lt;MoveCommand&gt;(robot, 0, 1);
    invoker.executeCommand(moveUp);
    
    // 취소(Undo) 실행
    std::cout &lt;&lt; "\n--- 명령 취소 ---" &lt;&lt; std::endl;
    invoker.undo();
    
    // 재실행(Redo) 실행
    std::cout &lt;&lt; "\n--- 명령 재실행 ---" &lt;&lt; std::endl;
    invoker.redo();
    
    // 더 많은 명령 실행
    auto moveLeft = std::make_shared&lt;MoveCommand&gt;(robot, -1, 0);
    invoker.executeCommand(moveLeft);
    
    // 연속된 취소 실행
    std::cout &lt;&lt; "\n--- 연속 취소 ---" &lt;&lt; std::endl;
    invoker.undo();
    invoker.undo();
    
    return 0;
}</code></pre>

                        <h3>4.3 복합 명령(매크로) 구현</h3>
                        <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;

// 복합 명령(매크로) 클래스
class MacroCommand : public Command {
private:
    std::vector&lt;std::shared_ptr&lt;Command&gt;&gt; commands;
    
public:
    void addCommand(std::shared_ptr&lt;Command&gt; command) {
        commands.push_back(command);
    }
    
    void execute() override {
        for (const auto&amp; command : commands) {
            command->execute();
        }
    }
    
    void undo() override {
        // 역순으로 명령 취소
        for (auto it = commands.rbegin(); it != commands.rend(); ++it) {
            (*it)->undo();
        }
    }
};

// 사용 예
void macroExample() {
    Robot robot;
    CommandInvoker invoker;
    
    // 매크로 명령 생성
    auto squarePattern = std::make_shared&lt;MacroCommand&gt;();
    
    // 정사각형 패턴을 그리는 명령들 추가
    squarePattern->addCommand(std::make_shared&lt;MoveCommand&gt;(robot, 1, 0));
    squarePattern->addCommand(std::make_shared&lt;MoveCommand&gt;(robot, 0, 1));
    squarePattern->addCommand(std::make_shared&lt;MoveCommand&gt;(robot, -1, 0));
    squarePattern->addCommand(std::make_shared&lt;MoveCommand&gt;(robot, 0, -1));
    
    // 매크로 실행
    std::cout &lt;&lt; "--- 정사각형 패턴 실행 ---" &lt;&lt; std::endl;
    invoker.executeCommand(squarePattern);
    
    // 매크로 취소 (전체가 한 번에 취소됨)
    std::cout &lt;&lt; "\n--- 정사각형 패턴 취소 ---" &lt;&lt; std::endl;
    invoker.undo();
}</code></pre>
                    </div>
                </div>

                <div class="content-section">
                    <div class="navigation-buttons">
                        <a href="../command.html" class="back-button">패턴 설명으로 돌아가기</a>
                        <a href="command_csharp.html" class="next-button">C# 코드 보기</a>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2024 GameDev PatternHub. All rights reserved.</p>
        </div>
    </footer>

    <script src="../../js/main.js"></script>
    <script>
        // 코드 하이라이팅 초기화
        document.addEventListener('DOMContentLoaded', (event) => {
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightBlock(block);
            });
        });
    </script>
</body>
</html>