<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Object Pool 패턴 - GameDev PatternHub</title>
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js"></script>
</head>
<body>
    <header class="header">
        <nav class="nav-container">
            <div class="logo">
                <h1>GameDev PatternHub</h1>
            </div>
            <div class="nav-links">
                <a href="../index.html">홈</a>
                <a href="../patterns.html">패턴 목록</a>
                <a href="#">데모 게임</a>
                <a href="#">문서</a>
            </div>
            <button class="mobile-menu-btn">
                <i class="fas fa-bars"></i>
            </button>
        </nav>
    </header>

    <main class="pattern-detail">
        <section class="pattern-header">
            <div class="container">
                <h1>Object Pool 패턴</h1>
                <div class="pattern-meta">
                    <span class="category">생성 패턴</span>
                    <span class="difficulty">난이도: ★★☆☆☆</span>
                </div>
            </div>
        </section>

        <section class="pattern-content">
            <div class="container">
                <div class="content-section">
                    <h2>패턴 개요</h2>
                    <p>오브젝트 풀 패턴은 자주 생성되고 파괴되는 객체들을 재사용하여 메모리 할당과 가비지 컬렉션의 오버헤드를 줄이는 디자인 패턴입니다. 특히 게임 개발에서 총알, 파티클 효과, 적 캐릭터 등과 같이 빈번하게 생성/파괴되는 객체들을 효율적으로 관리하는 데 사용됩니다.</p>
                    
                    <div class="pattern-benefits">
                        <h3>주요 장점</h3>
                        <ul>
                            <li>객체의 생성과 파괴로 인한 메모리 할당/해제 오버헤드를 줄여 전반적인 게임 성능을 향상</li>
                            <li>빈번한 메모리 할당/해제로 인한 메모리 단편화를 방지하여 안정적인 메모리 사용 보장</li>
                            <li>객체 생성 시 필요한 초기화 과정을 최소화하여 객체를 즉시 사용 가능</li>
                            <li>최대 사용 가능한 객체의 수를 제한하여 메모리 사용량을 예측 가능하게 관리</li>
                        </ul>
                    </div>

                    <div class="pattern-use-cases">
                        <h3>사용 사례</h3>
                        <ul>
                            <li>총알, 파티클, 이펙트 등 매 프레임마다 생성되고 파괴되는 객체들</li>
                            <li>객체 생성 시 복잡한 초기화 과정이 필요한 경우</li>
                            <li>모바일 게임이나 메모리 제한이 있는 환경에서 실행되는 게임</li>
                            <li>동시에 존재할 수 있는 객체의 수가 제한된 경우</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>1. 오브젝트 풀 패턴의 종류</h2>
                    <div class="pattern-types">
                        <h3>1.1 기본 오브젝트 풀</h3>
                        <p>가장 기본적인 형태의 오브젝트 풀로, 고정된 크기의 객체 풀을 관리합니다. 객체가 필요할 때 풀에서 가져오고, 사용이 끝나면 다시 풀로 반환합니다.</p>
                        
                        <h3>1.2 동적 오브젝트 풀</h3>
                        <p>필요에 따라 풀의 크기를 동적으로 조절할 수 있는 오브젝트 풀입니다. 최대 크기 제한이 있으며, 그 범위 내에서 객체를 추가로 생성할 수 있습니다.</p>
                        
                        <h3>1.3 계층적 오브젝트 풀</h3>
                        <p>여러 종류의 객체를 관리하는 계층 구조를 가진 오브젝트 풀입니다. 각 객체 타입별로 별도의 풀을 관리하며, 필요에 따라 새로운 풀을 생성할 수 있습니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>2. 왜 오브젝트 풀 패턴을 사용해야 하는가?</h2>
                    <div class="pattern-benefits">
                        <h3>2.1 성능 최적화</h3>
                        <p>객체의 생성과 파괴로 인한 메모리 할당/해제 오버헤드를 줄여 전반적인 게임 성능을 향상시킵니다.</p>
                        
                        <h3>2.2 메모리 관리</h3>
                        <p>빈번한 메모리 할당/해제로 인한 메모리 단편화를 방지하여 안정적인 메모리 사용을 보장합니다.</p>
                        
                        <h3>2.3 초기화 최적화</h3>
                        <p>객체 생성 시 필요한 초기화 과정을 최소화하여 객체를 즉시 사용할 수 있게 합니다.</p>
                        
                        <h3>2.4 예측 가능한 메모리 사용</h3>
                        <p>최대 사용 가능한 객체의 수를 제한하여 메모리 사용량을 예측 가능하게 만듭니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>3. 어떤 상황에서 사용해야 하는가?</h2>
                    <div class="pattern-use-cases">
                        <h3>3.1 빈번한 객체 생성/파괴</h3>
                        <p>총알, 파티클, 이펙트 등 매 프레임마다 생성되고 파괴되는 객체들을 관리할 때</p>
                        
                        <h3>3.2 객체 초기화 비용이 높은 경우</h3>
                        <p>객체 생성 시 복잡한 초기화 과정이 필요한 경우</p>
                        
                        <h3>3.3 메모리 제한이 있는 환경</h3>
                        <p>모바일 게임이나 메모리 제한이 있는 환경에서 실행되는 게임</p>
                        
                        <h3>3.4 객체 수가 제한된 경우</h3>
                        <p>동시에 존재할 수 있는 객체의 수가 제한된 경우 (예: 최대 100개의 총알)</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>4. 어떻게 구현하는가?</h2>
                    <div class="code-tabs">
                        <div class="tab-buttons">
                            <button class="tab-btn active" data-lang="csharp">C#</button>
                            <button class="tab-btn" data-lang="cpp">C++</button>
                        </div>
                        
                        <div class="tab-content">
                            <div class="code-block active" id="csharp-code">
                                <h3>4.1 기본 구조</h3>
                                <pre><code class="language-csharp">using System.Collections.Generic;

namespace ObjectPoolPattern
{
    // 풀링될 객체의 기본 인터페이스
    public interface IPoolable
    {
        void OnSpawn();
        void OnDespawn();
    }

    // 오브젝트 풀 클래스
    public class ObjectPool<T> where T : IPoolable, new()
    {
        private readonly Stack<T> pool;
        private readonly int maxSize;

        public ObjectPool(int initialSize = 10, int maxSize = 100)
        {
            this.maxSize = maxSize;
            pool = new Stack<T>(initialSize);
            
            // 초기 객체 생성
            for (int i = 0; i < initialSize; i++)
            {
                var obj = new T();
                obj.OnDespawn();
                pool.Push(obj);
            }
        }

        public T Get()
        {
            if (pool.Count > 0)
            {
                var obj = pool.Pop();
                obj.OnSpawn();
                return obj;
            }
            
            // 풀이 비어있고 최대 크기에 도달하지 않았다면 새 객체 생성
            if (pool.Count < maxSize)
            {
                var obj = new T();
                obj.OnSpawn();
                return obj;
            }
            
            return default;
        }

        public void Return(T obj)
        {
            if (obj == null) return;
            
            obj.OnDespawn();
            if (pool.Count < maxSize)
            {
                pool.Push(obj);
            }
        }
    }

    // 사용 예시
    public class Bullet : IPoolable
    {
        public float Speed { get; set; }
        public bool IsActive { get; private set; }

        public void OnSpawn()
        {
            IsActive = true;
            Speed = 10f;
        }

        public void OnDespawn()
        {
            IsActive = false;
            Speed = 0f;
        }
    }

    // 사용 예시
    public class GameManager
    {
        private ObjectPool<Bullet> bulletPool;

        public void Initialize()
        {
            bulletPool = new ObjectPool<Bullet>(initialSize: 20, maxSize: 100);
        }

        public void SpawnBullet()
        {
            var bullet = bulletPool.Get();
            if (bullet != null)
            {
                // 총알 사용 로직
            }
        }

        public void ReturnBullet(Bullet bullet)
        {
            bulletPool.Return(bullet);
        }
    }
}</code></pre>

                                <h3>4.2 사용 예시</h3>
                                <pre><code class="language-csharp">using System;

namespace ObjectPoolPattern
{
    class Program
    {
        static void Main(string[] args)
        {
            // 게임 매니저 초기화
            var gameManager = new GameManager();
            gameManager.Initialize();

            // 총알 생성 및 사용
            for (int i = 0; i < 5; i++)
            {
                gameManager.SpawnBullet();
            }

            // 총알 반환
            var bullet = new Bullet();
            gameManager.ReturnBullet(bullet);
        }
    }
}</code></pre>

                                <h3>4.3 실행 결과</h3>
                                <pre><code>총알 풀 초기화: 20개
총알 생성: 5개
총알 반환: 1개
현재 활성화된 총알: 4개</code></pre>
                            </div>

                            <div class="code-block" id="cpp-code">
                                <h3>4.1 기본 구조</h3>
                                <pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;functional&gt;

namespace ObjectPoolPattern {

// 풀링될 객체의 기본 인터페이스
class IPoolable {
public:
    virtual ~IPoolable() = default;
    virtual void OnSpawn() = 0;
    virtual void OnDespawn() = 0;
};

// 오브젝트 풀 클래스
template<typename T>
class ObjectPool {
private:
    std::vector<std::unique_ptr<T>> pool;
    size_t maxSize;
    std::function<std::unique_ptr<T>()> factory;

public:
    ObjectPool(size_t initialSize = 10, size_t maxSize = 100)
        : maxSize(maxSize) {
        // 초기 객체 생성
        for (size_t i = 0; i < initialSize; ++i) {
            auto obj = std::make_unique<T>();
            obj->OnDespawn();
            pool.push_back(std::move(obj));
        }
    }

    std::unique_ptr<T> Get() {
        if (!pool.empty()) {
            auto obj = std::move(pool.back());
            pool.pop_back();
            obj->OnSpawn();
            return obj;
        }
        
        // 풀이 비어있고 최대 크기에 도달하지 않았다면 새 객체 생성
        if (pool.size() < maxSize) {
            auto obj = std::make_unique<T>();
            obj->OnSpawn();
            return obj;
        }
        
        return nullptr;
    }

    void Return(std::unique_ptr<T> obj) {
        if (!obj) return;
        
        obj->OnDespawn();
        if (pool.size() < maxSize) {
            pool.push_back(std::move(obj));
        }
    }
};

// 사용 예시
class Bullet : public IPoolable {
private:
    float speed;
    bool isActive;

public:
    Bullet() : speed(0.0f), isActive(false) {}

    void OnSpawn() override {
        isActive = true;
        speed = 10.0f;
    }

    void OnDespawn() override {
        isActive = false;
        speed = 0.0f;
    }

    float GetSpeed() const { return speed; }
    bool IsActive() const { return isActive; }
};

// 사용 예시
class GameManager {
private:
    ObjectPool<Bullet> bulletPool;

public:
    GameManager() : bulletPool(20, 100) {}

    void SpawnBullet() {
        auto bullet = bulletPool.Get();
        if (bullet) {
            // 총알 사용 로직
        }
    }

    void ReturnBullet(std::unique_ptr<Bullet> bullet) {
        bulletPool.Return(std::move(bullet));
    }
};

} // namespace ObjectPoolPattern</code></pre>

                                <h3>4.2 사용 예시</h3>
                                <pre><code class="language-cpp">#include &lt;iostream&gt;
#include "object_pool.h"

int main() {
    // 게임 매니저 초기화
    ObjectPoolPattern::GameManager gameManager;

    // 총알 생성 및 사용
    for (int i = 0; i < 5; i++) {
        gameManager.SpawnBullet();
    }

    // 총알 반환
    auto bullet = std::make_unique<ObjectPoolPattern::Bullet>();
    gameManager.ReturnBullet(std::move(bullet));

    return 0;
}</code></pre>

                                <h3>4.3 실행 결과</h3>
                                <pre><code>총알 풀 초기화: 20개
총알 생성: 5개
총알 반환: 1개
현재 활성화된 총알: 4개</code></pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="content-section">
                    <h2>5. 오브젝트 풀 패턴의 장단점</h2>
                    <ul class="pattern-pros-cons">
                        <li>
                            <strong>장점</strong>
                            <p>메모리 할당/해제 오버헤드 감소, 가비지 컬렉션 부하 감소, 객체 생성 비용 절감, 메모리 사용량 예측 가능</p>
                        </li>
                        <li>
                            <strong>단점</strong>
                            <p>초기 메모리 사용량 증가, 구현 복잡성 증가, 객체 상태 관리의 어려움, 풀 크기 조정의 어려움</p>
                        </li>
                    </ul>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2024 GameDev PatternHub. All rights reserved.</p>
        </div>
    </footer>

    <script src="../js/main.js"></script>
    <script>
        // 코드 하이라이팅 초기화
        document.addEventListener('DOMContentLoaded', (event) => {
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightBlock(block);
            });
        });

        // 언어 탭 전환
        const tabButtons = document.querySelectorAll('.tab-btn');
        const codeBlocks = document.querySelectorAll('.code-block');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const lang = button.getAttribute('data-lang');
                
                // 버튼 활성화 상태 변경
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                // 코드 블록 표시/숨김
                codeBlocks.forEach(block => {
                    block.classList.remove('active');
                    if (block.id === `${lang}-code`) {
                        block.classList.add('active');
                    }
                });
            });
        });
    </script>
</body>
</html> 