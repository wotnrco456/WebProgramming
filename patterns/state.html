<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>State 패턴 - GameDev PatternHub</title>
    <link rel="stylesheet" href="../css/common.css">
    <link rel="stylesheet" href="../css/layout.css">
    <link rel="stylesheet" href="../css/pattern-detail.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <header class="header">
        <nav class="nav-container">
            <div class="logo">
                <h1>GameDev PatternHub</h1>
            </div>
            <div class="nav-links">
                <a href="../index.html">홈</a>
                <a href="../patterns.html">패턴 목록</a>
                <a href="#">데모 게임</a>
                <a href="#">문서</a>
            </div>
            <button class="mobile-menu-btn">
                <i class="fas fa-bars"></i>
            </button>
        </nav>
    </header>

    <main class="pattern-detail">
        <section class="pattern-header">
            <div class="container">
                <h1>State 패턴</h1>
                <div class="pattern-meta">
                    <span class="category">행동 패턴</span>
                    <span class="difficulty">난이도: ★★★☆☆</span>
                </div>
            </div>
        </section>

        <section class="pattern-content">
            <div class="container">
                <div class="content-section">
                    <h2>패턴 개요</h2>
                    <p>State 패턴은 객체의 내부 상태가 변할 때 객체의 행동이 바뀌는 것처럼 보이게 하는 행동 디자인 패턴입니다. 객체가 자신의 현재 상태에 따라 다르게 행동하도록 만들고, 상태 전환 로직을 캡슐화하여 코드의 구조와 유지보수성을 개선합니다. 게임 개발에서는 캐릭터 AI, 게임 오브젝트 상태 관리, UI 상태 제어 등에 널리 사용됩니다.</p>
                    
                    <div class="pattern-benefits">
                        <h3>주요 장점</h3>
                        <ul>
                            <li>객체의 상태별 행동을 클래스로 캡슐화하여 코드 구조 개선</li>
                            <li>상태 전환 로직 분리로 분기 처리(if-else) 복잡성 감소</li>
                            <li>새로운 상태 추가가 용이하여 확장성 향상</li>
                            <li>상태별 로직 분리로 유지보수성 개선</li>
                            <li>상태 간 전환을 명확하게 표현하여 디버깅 용이</li>
                        </ul>
                    </div>

                    <div class="pattern-use-cases">
                        <h3>사용 사례</h3>
                        <ul>
                            <li>캐릭터 상태 관리 (대기, 걷기, 달리기, 점프 등)</li>
                            <li>AI 행동 시스템 구현</li>
                            <li>게임 상태 관리 (메뉴, 플레이, 일시정지, 게임오버 등)</li>
                            <li>UI 상태 제어 (비활성, 활성, 선택됨, 클릭됨 등)</li>
                            <li>인터랙티브 오브젝트의 상태 관리</li>
                            <li>애니메이션 시스템 구현</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>1. State 패턴의 기본 개념</h2>
                    <p>State 패턴의 핵심은 다음과 같습니다:</p>
                    <div class="pattern-pros-cons">
                        <ul>
                            <li><strong>Context (컨텍스트)</strong> - 현재 상태를 유지하고, 상태 객체에 작업을 위임하는 클래스</li>
                            <li><strong>State (상태) 인터페이스</strong> - 모든 구체적인 상태 클래스가 구현해야 하는 공통 인터페이스</li>
                            <li><strong>ConcreteState (구체적인 상태)</strong> - State 인터페이스를 구현하는 클래스로, 특정 상태에서의 행동을 정의</li>
                            <li><strong>상태 전환 메커니즘</strong> - 현재 상태에서 다른 상태로 전환하는 방법</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>2. 왜 State 패턴을 사용해야 하는가?</h2>
                    <div class="pattern-benefits">
                        <h3>2.1 상태별 행동 캡슐화</h3>
                        <p>각 상태의 행동을 별도의 클래스로 캡슐화하여, 특정 상태와 관련된 모든 동작을 한 곳에서 관리할 수 있습니다. 이는 코드의 가독성과 유지보수성을 크게 향상시킵니다.</p>
                        
                        <h3>2.2 분기 로직 감소</h3>
                        <p>복잡한 if-else 또는 switch-case 문을 제거하고, 다형성을 활용한 상태 객체의 메서드 호출로 대체할 수 있습니다. 이는 코드의 복잡성을 줄이고 버그 발생 가능성을 감소시킵니다.</p>
                        
                        <h3>2.3 확장성 향상</h3>
                        <p>새로운 상태를 추가하려면 새 State 클래스를 구현하고 필요한 상태 전환 로직을 추가하면 됩니다. 기존 코드의 수정 없이 새로운 상태와 동작을 추가할 수 있습니다.</p>
                        
                        <h3>2.4 상태 전환 명확화</h3>
                        <p>상태 전환 로직이 명확하게 표현되어 어떤 조건에서 상태가 변경되는지 쉽게 파악할 수 있습니다. 이는 디버깅과 시스템 동작 이해에 큰 도움이 됩니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>3. 어떤 상황에서 사용해야 하는가?</h2>
                    <div class="pattern-use-cases">
                        <h3>3.1 객체의 상태에 따라 행동이 크게 달라지는 경우</h3>
                        <p>객체가 자신의 현재 상태에 따라 다른 행동을 해야 하고, 실행 중에 상태가 자주 변경되는 경우에 적합합니다. 대표적으로 게임 캐릭터의 상태(대기, 걷기, 달리기, 점프 등)가 있습니다.</p>
                        
                        <h3>3.2 상태 전환 조건이 복잡한 경우</h3>
                        <p>상태 간 전환 조건이 복잡하고 다양한 경우, 이를 명확하게 표현하고 관리하는 데 도움이 됩니다. 예를 들어, 게임 AI의 의사결정 로직이 있습니다.</p>
                        
                        <h3>3.3 코드의 분기 처리가 복잡해지는 경우</h3>
                        <p>객체의 상태에 따른 분기 처리가 많아져 if-else 또는 switch-case 문이 복잡해지는 경우, State 패턴으로 코드를 정리할 수 있습니다.</p>
                        
                        <h3>3.4 단계별 프로세스 관리가 필요한 경우</h3>
                        <p>게임의 단계별 진행, 턴 기반 게임의 턴 관리, 또는 UI 흐름 제어와 같이 명확한 단계와 전환 규칙이 있는 프로세스에 적합합니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>4. 어떻게 구현하는가?</h2>
                    <p>State 패턴의 구현은 다양한 언어로 가능합니다. 아래 링크를 통해 각 언어별 구현 코드를 확인할 수 있습니다.</p>
                    
                    <div class="code-tabs">
                        <div class="code-language-buttons">
                            <a href="codes/state_csharp.html" class="code-language-btn">C# 코드 보기</a>
                            <a href="codes/state_cpp.html" class="code-language-btn">C++ 코드 보기</a>
                        </div>
                    </div>
                </div>

                <div class="content-section">
                    <h2>5. State 패턴의 장단점</h2>
                    <div class="pattern-pros-cons">
                        <h3>5.1 장점</h3>
                        <ul>
                            <li>
                                <strong>단일 책임 원칙 준수</strong>
                                <p>각 상태와 관련된 코드를 별도 클래스로 분리하여 단일 책임 원칙을 충족시킵니다.</p>
                            </li>
                            <li>
                                <strong>개방/폐쇄 원칙 준수</strong>
                                <p>기존 코드를 수정하지 않고도 새 상태를 추가할 수 있어 확장성이 뛰어납니다.</p>
                            </li>
                            <li>
                                <strong>코드 구조와 가독성 향상</strong>
                                <p>복잡한 조건문이 제거되고 상태 동작이 명확하게 분리되어 코드의 가독성이 향상됩니다.</p>
                            </li>
                            <li>
                                <strong>상태 전환 로직 명확화</strong>
                                <p>상태 전환 조건과 프로세스가 명확하게 정의되어 있어 디버깅과 유지보수가 용이합니다.</p>
                            </li>
                        </ul>

                        <h3>5.2 단점</h3>
                        <ul>
                            <li>
                                <strong>클래스 수 증가</strong>
                                <p>각 상태마다 별도의 클래스가 필요하여 클래스 수가 증가할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>상태 간 데이터 공유 어려움</strong>
                                <p>상태 간에 데이터를 공유해야 하는 경우 컨텍스트 클래스를 통해 전달해야 하므로 설계가 복잡해질 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>상태가 적은 경우 오버헤드</strong>
                                <p>상태의 수가 적고 상태 전환이 단순한 경우, State 패턴을 적용하는 것이 불필요한 복잡성을 추가할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>상태 간 의존성</strong>
                                <p>상태 객체가 컨텍스트와 다른 상태에 대한 참조를 가져야 할 경우, 의존성이 증가하고 결합도가 높아질 수 있습니다.</p>
                            </li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>6. 주의사항 및 모범 사례</h2>
                    <div class="pattern-pros-cons">
                        <ul>
                            <li>
                                <strong>상태 전환 책임 명확화</strong>
                                <p>상태 전환의 책임이 상태 객체에 있는지, 컨텍스트에 있는지 명확히 정의하세요. 프로젝트의 일관성을 위해 한 가지 접근 방식을 선택하는 것이 좋습니다.</p>
                            </li>
                            <li>
                                <strong>상태 머신 구조화</strong>
                                <p>상태가 많고 복잡한 경우, 계층적 상태 머신을 고려하여 상태 관리를 구조화하세요. 이를 통해 상태 간의 관계와 전환을 더 명확하게 표현할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>메모리 관리</strong>
                                <p>많은 상태 객체를 생성하는 경우, 메모리 사용량에 주의하세요. 상황에 따라 객체 풀링이나 정적 인스턴스를 사용하는 것을 고려하세요.</p>
                            </li>
                            <li>
                                <strong>상태 디버깅 도구</strong>
                                <p>복잡한 상태 머신의 경우, 상태 전환과 현재 상태를 로깅하거나 시각화하는 도구를 개발하면 디버깅과 개발이 용이해집니다.</p>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2024 GameDev PatternHub. All rights reserved.</p>
        </div>
    </footer>

    <script src="../js/main.js"></script>
</body>
</html>