<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>State 패턴 - GameDev PatternHub</title>
    <link rel="stylesheet" href="../css/common.css">
    <link rel="stylesheet" href="../css/layout.css">
    <link rel="stylesheet" href="../css/pattern-detail.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js"></script>
</head>
<body>
    <header class="header">
        <nav class="nav-container">
            <div class="logo">
                <h1>GameDev PatternHub</h1>
            </div>
            <div class="nav-links">
                <a href="../index.html">홈</a>
                <a href="../patterns.html">패턴 목록</a>
                <a href="#">데모 게임</a>
                <a href="#">문서</a>
            </div>
            <button class="mobile-menu-btn">
                <i class="fas fa-bars"></i>
            </button>
        </nav>
    </header>

    <main class="pattern-detail">
        <section class="pattern-header">
            <div class="container">
                <h1>State 패턴</h1>
                <div class="pattern-meta">
                    <span class="category">행동 패턴</span>
                    <span class="difficulty">난이도: ★★★☆☆</span>
                </div>
            </div>
        </section>

        <section class="pattern-content">
            <div class="container">
                <div class="content-section">
                    <h2>패턴 개요</h2>
                    <p>State 패턴은 객체의 내부 상태가 변할 때 객체의 행동이 바뀌는 것처럼 보이게 하는 행동 디자인 패턴입니다. 객체가 자신의 현재 상태에 따라 다르게 행동하도록 만들고, 상태 전환 로직을 캡슐화하여 코드의 구조와 유지보수성을 개선합니다. 게임 개발에서는 캐릭터 AI, 게임 오브젝트 상태 관리, UI 상태 제어 등에 널리 사용됩니다.</p>
                    
                    <div class="pattern-benefits">
                        <h3>주요 장점</h3>
                        <ul>
                            <li>객체의 상태별 행동을 클래스로 캡슐화하여 코드 구조 개선</li>
                            <li>상태 전환 로직 분리로 분기 처리(if-else) 복잡성 감소</li>
                            <li>새로운 상태 추가가 용이하여 확장성 향상</li>
                            <li>상태별 로직 분리로 유지보수성 개선</li>
                            <li>상태 간 전환을 명확하게 표현하여 디버깅 용이</li>
                        </ul>
                    </div>

                    <div class="pattern-use-cases">
                        <h3>사용 사례</h3>
                        <ul>
                            <li>캐릭터 상태 관리 (대기, 걷기, 달리기, 점프 등)</li>
                            <li>AI 행동 시스템 구현</li>
                            <li>게임 상태 관리 (메뉴, 플레이, 일시정지, 게임오버 등)</li>
                            <li>UI 상태 제어 (비활성, 활성, 선택됨, 클릭됨 등)</li>
                            <li>인터랙티브 오브젝트의 상태 관리</li>
                            <li>애니메이션 시스템 구현</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>1. State 패턴의 기본 개념</h2>
                    <p>State 패턴의 핵심은 다음과 같습니다:</p>
                    <div class="pattern-pros-cons">
                        <ul>
                            <li><strong>Context (컨텍스트)</strong> - 현재 상태를 유지하고, 상태 객체에 작업을 위임하는 클래스</li>
                            <li><strong>State (상태) 인터페이스</strong> - 모든 구체적인 상태 클래스가 구현해야 하는 공통 인터페이스</li>
                            <li><strong>ConcreteState (구체적인 상태)</strong> - State 인터페이스를 구현하는 클래스로, 특정 상태에서의 행동을 정의</li>
                            <li><strong>상태 전환 메커니즘</strong> - 현재 상태에서 다른 상태로 전환하는 방법</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>2. 왜 State 패턴을 사용해야 하는가?</h2>
                    <div class="pattern-benefits">
                        <h3>2.1 상태별 행동 캡슐화</h3>
                        <p>각 상태의 행동을 별도의 클래스로 캡슐화하여, 특정 상태와 관련된 모든 동작을 한 곳에서 관리할 수 있습니다. 이는 코드의 가독성과 유지보수성을 크게 향상시킵니다.</p>
                        
                        <h3>2.2 분기 로직 감소</h3>
                        <p>복잡한 if-else 또는 switch-case 문을 제거하고, 다형성을 활용한 상태 객체의 메서드 호출로 대체할 수 있습니다. 이는 코드의 복잡성을 줄이고 버그 발생 가능성을 감소시킵니다.</p>
                        
                        <h3>2.3 확장성 향상</h3>
                        <p>새로운 상태를 추가하려면 새 State 클래스를 구현하고 필요한 상태 전환 로직을 추가하면 됩니다. 기존 코드의 수정 없이 새로운 상태와 동작을 추가할 수 있습니다.</p>
                        
                        <h3>2.4 상태 전환 명확화</h3>
                        <p>상태 전환 로직이 명확하게 표현되어 어떤 조건에서 상태가 변경되는지 쉽게 파악할 수 있습니다. 이는 디버깅과 시스템 동작 이해에 큰 도움이 됩니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>3. 어떤 상황에서 사용해야 하는가?</h2>
                    <div class="pattern-use-cases">
                        <h3>3.1 객체의 상태에 따라 행동이 크게 달라지는 경우</h3>
                        <p>객체가 자신의 현재 상태에 따라 다른 행동을 해야 하고, 실행 중에 상태가 자주 변경되는 경우에 적합합니다. 대표적으로 게임 캐릭터의 상태(대기, 걷기, 달리기, 점프 등)가 있습니다.</p>
                        
                        <h3>3.2 상태 전환 조건이 복잡한 경우</h3>
                        <p>상태 간 전환 조건이 복잡하고 다양한 경우, 이를 명확하게 표현하고 관리하는 데 도움이 됩니다. 예를 들어, 게임 AI의 의사결정 로직이 있습니다.</p>
                        
                        <h3>3.3 코드의 분기 처리가 복잡해지는 경우</h3>
                        <p>객체의 상태에 따른 분기 처리가 많아져 if-else 또는 switch-case 문이 복잡해지는 경우, State 패턴으로 코드를 정리할 수 있습니다.</p>
                        
                        <h3>3.4 단계별 프로세스 관리가 필요한 경우</h3>
                        <p>게임의 단계별 진행, 턴 기반 게임의 턴 관리, 또는 UI 흐름 제어와 같이 명확한 단계와 전환 규칙이 있는 프로세스에 적합합니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>4. 어떻게 구현하는가?</h2>
                    <div class="code-tabs">
                        <div class="tab-buttons">
                            <button class="tab-btn active" data-lang="csharp">C#</button>
                            <button class="tab-btn" data-lang="cpp">C++</button>
                        </div>
                        
                        <div class="tab-content">
                            <div class="code-block active" id="csharp-code">
                                <h3>4.1 기본 구조</h3>
                                <pre><code class="language-csharp">using System;

namespace StatePattern
{
    // 상태 인터페이스
    public interface IState
    {
        void Enter();  // 상태 진입 시 실행할 로직
        void Execute(); // 상태 유지 중 매 프레임 실행할 로직
        void Exit();   // 상태 종료 시 실행할 로직
    }

    // 컨텍스트 클래스
    public class Character
    {
        public IState CurrentState { get; private set; }
        
        // 상태 객체들
        public IdleState IdleState { get; private set; }
        public WalkState WalkState { get; private set; }
        public JumpState JumpState { get; private set; }
        
        // 캐릭터 속성
        public bool IsGrounded { get; set; } = true;
        public float HorizontalInput { get; set; } = 0f;
        public bool JumpPressed { get; set; } = false;
        
        // 상태 변경 이벤트
        public event Action&lt;IState&gt; OnStateChanged;
        
        public Character()
        {
            // 상태 객체 초기화
            IdleState = new IdleState(this);
            WalkState = new WalkState(this);
            JumpState = new JumpState(this);
            
            // 초기 상태 설정
            TransitionToState(IdleState);
        }
        
        // 상태 전환 메서드
        public void TransitionToState(IState newState)
        {
            CurrentState?.Exit();
            CurrentState = newState;
            CurrentState.Enter();
            
            // 상태 변경 이벤트 발생
            OnStateChanged?.Invoke(CurrentState);
        }
        
        // 상태 업데이트 메서드
        public void Update()
        {
            CurrentState?.Execute();
        }
    }

    // 대기 상태
    public class IdleState : IState
    {
        private Character character;
        
        public IdleState(Character character)
        {
            this.character = character;
        }
        
        public void Enter()
        {
            Console.WriteLine("대기 상태 시작");
        }
        
        public void Execute()
        {
            // 대기 상태에서의 전환 조건 검사
            if (!character.IsGrounded)
            {
                character.TransitionToState(character.JumpState);
                return;
            }
            
            if (Math.Abs(character.HorizontalInput) > 0.1f)
            {
                character.TransitionToState(character.WalkState);
                return;
            }
        }
        
        public void Exit()
        {
            Console.WriteLine("대기 상태 종료");
        }
    }

    // 걷기 상태
    public class WalkState : IState
    {
        private Character character;
        
        public WalkState(Character character)
        {
            this.character = character;
        }
        
        public void Enter()
        {
            Console.WriteLine("걷기 상태 시작");
        }
        
        public void Execute()
        {
            // 걷기 상태에서의 전환 조건 검사
            if (!character.IsGrounded)
            {
                character.TransitionToState(character.JumpState);
                return;
            }
            
            if (Math.Abs(character.HorizontalInput) < 0.1f)
            {
                character.TransitionToState(character.IdleState);
                return;
            }
            
            if (character.JumpPressed && character.IsGrounded)
            {
                character.TransitionToState(character.JumpState);
                return;
            }
            
            // 걷기 로직 실행
            Console.WriteLine($"캐릭터가 {character.HorizontalInput} 방향으로 걷는 중");
        }
        
        public void Exit()
        {
            Console.WriteLine("걷기 상태 종료");
        }
    }

    // 점프 상태
    public class JumpState : IState
    {
        private Character character;
        
        public JumpState(Character character)
        {
            this.character = character;
        }
        
        public void Enter()
        {
            Console.WriteLine("점프 상태 시작");
            // 점프 시작 로직
        }
        
        public void Execute()
        {
            // 점프 상태에서의 전환 조건 검사
            if (character.IsGrounded)
            {
                if (Math.Abs(character.HorizontalInput) > 0.1f)
                {
                    character.TransitionToState(character.WalkState);
                }
                else
                {
                    character.TransitionToState(character.IdleState);
                }
                return;
            }
            
            // 점프 중 로직 실행
            Console.WriteLine("캐릭터가 점프 중");
        }
        
        public void Exit()
        {
            Console.WriteLine("점프 상태 종료");
            character.JumpPressed = false;
        }
    }
}</code></pre>

                                <h3>4.2 사용 예시</h3>
                                <pre><code class="language-csharp">using System;

namespace StatePattern
{
    class Program
    {
        static void Main(string[] args)
        {
            // 캐릭터 생성
            Character character = new Character();
            
            // 상태 변경 이벤트 구독
            character.OnStateChanged += state => Console.WriteLine($"상태 변경됨: {state.GetType().Name}");
            
            // 대기 상태 시작 (초기 상태)
            Console.WriteLine("\n--- 초기 상태(대기) ---");
            character.Update();
            
            // 걷기 상태로 전환
            Console.WriteLine("\n--- 걷기 시작 ---");
            character.HorizontalInput = 1.0f;
            character.Update();
            
            // 걷기 상태 유지
            Console.WriteLine("\n--- 걷기 유지 ---");
            character.Update();
            
            // 점프 상태로 전환
            Console.WriteLine("\n--- 점프 시작 ---");
            character.JumpPressed = true;
            character.IsGrounded = false;
            character.Update();
            
            // 착지 후 대기 상태로 전환
            Console.WriteLine("\n--- 착지(대기) ---");
            character.HorizontalInput = 0.0f;
            character.IsGrounded = true;
            character.Update();
        }
    }
}</code></pre>

                                <h3>4.3 계층적 상태 시스템 구현</h3>
                                <pre><code class="language-csharp">using System;
using System.Collections.Generic;

namespace StatePattern
{
    // 계층적 상태 관리를 위한 상태 머신
    public class StateMachine
    {
        private Dictionary&lt;Type, IState&gt; states = new Dictionary&lt;Type, IState&gt;();
        private IState currentState;
        
        // 상태 등록
        public void RegisterState(IState state)
        {
            states[state.GetType()] = state;
        }
        
        // 특정 타입의 상태로 전환
        public void TransitionTo&lt;T&gt;() where T : IState
        {
            if (states.TryGetValue(typeof(T), out IState newState))
            {
                currentState?.Exit();
                currentState = newState;
                currentState.Enter();
            }
        }
        
        // 상태 업데이트
        public void Update()
        {
            currentState?.Execute();
        }
    }
    
    // 복합 상태 예시 - 이동 상태와 하위 상태들
    public class MovementState : IState
    {
        protected Character character;
        protected StateMachine stateMachine = new StateMachine();
        
        public MovementState(Character character)
        {
            this.character = character;
            
            // 하위 상태 등록
            stateMachine.RegisterState(new WalkingSubState(this));
            stateMachine.RegisterState(new RunningSubState(this));
        }
        
        public virtual void Enter()
        {
            Console.WriteLine("이동 상태 시작");
            
            // 기본 하위 상태 설정
            stateMachine.TransitionTo&lt;WalkingSubState&gt;();
        }
        
        public virtual void Execute()
        {
            // 상위 상태에서의 전환 조건 검사
            if (!character.IsGrounded)
            {
                character.TransitionToState(character.JumpState);
                return;
            }
            
            if (Math.Abs(character.HorizontalInput) < 0.1f)
            {
                character.TransitionToState(character.IdleState);
                return;
            }
            
            // 하위 상태 업데이트
            stateMachine.Update();
        }
        
        public virtual void Exit()
        {
            Console.WriteLine("이동 상태 종료");
        }
        
        // 달리기 전환 메서드
        public void StartRunning()
        {
            stateMachine.TransitionTo&lt;RunningSubState&gt;();
        }
        
        // 걷기 전환 메서드
        public void StartWalking()
        {
            stateMachine.TransitionTo&lt;WalkingSubState&gt;();
        }
    }
    
    // 걷기 하위 상태
    public class WalkingSubState : IState
    {
        private MovementState parentState;
        
        public WalkingSubState(MovementState parentState)
        {
            this.parentState = parentState;
        }
        
        public void Enter()
        {
            Console.WriteLine("걷기 하위 상태 시작");
        }
        
        public void Execute()
        {
            Console.WriteLine("캐릭터가 걷는 중");
            
            // 달리기 상태로 전환 조건 검사
            if (Math.Abs(((dynamic)parentState).character.HorizontalInput) > 0.8f)
            {
                parentState.StartRunning();
            }
        }
        
        public void Exit()
        {
            Console.WriteLine("걷기 하위 상태 종료");
        }
    }
    
    // 달리기 하위 상태
    public class RunningSubState : IState
    {
        private MovementState parentState;
        
        public RunningSubState(MovementState parentState)
        {
            this.parentState = parentState;
        }
        
        public void Enter()
        {
            Console.WriteLine("달리기 하위 상태 시작");
        }
        
        public void Execute()
        {
            Console.WriteLine("캐릭터가 달리는 중");
            
            // 걷기 상태로 전환 조건 검사
            if (Math.Abs(((dynamic)parentState).character.HorizontalInput) <= 0.8f)
            {
                parentState.StartWalking();
            }
        }
        
        public void Exit()
        {
            Console.WriteLine("달리기 하위 상태 종료");
        }
    }
}</code></pre>
                            </div>

                            <div class="code-block" id="cpp-code">
                                <h3>4.1 기본 구조</h3>
                                <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
#include &lt;cmath&gt;
#include &lt;functional&gt;
#include &lt;vector&gt;
#include &lt;typeinfo&gt;

// 전방 선언
class Character;

// 상태 인터페이스
class IState {
public:
    virtual ~IState() = default;
    
    virtual void Enter() = 0;  // 상태 진입 시 실행할 로직
    virtual void Execute() = 0; // 상태 유지 중 매 프레임 실행할 로직
    virtual void Exit() = 0;   // 상태 종료 시 실행할 로직
};

// 대기 상태
class IdleState : public IState {
private:
    Character* character;
    
public:
    IdleState(Character* character);
    
    void Enter() override;
    void Execute() override;
    void Exit() override;
};

// 걷기 상태
class WalkState : public IState {
private:
    Character* character;
    
public:
    WalkState(Character* character);
    
    void Enter() override;
    void Execute() override;
    void Exit() override;
};

// 점프 상태
class JumpState : public IState {
private:
    Character* character;
    
public:
    JumpState(Character* character);
    
    void Enter() override;
    void Execute() override;
    void Exit() override;
};

// 컨텍스트 클래스
class Character {
private:
    std::shared_ptr<IState> currentState;
    std::vector<std::function<void(std::shared_ptr<IState>)>> stateChangedCallbacks;
    
public:
    std::shared_ptr<IdleState> idleState;
    std::shared_ptr<WalkState> walkState;
    std::shared_ptr<JumpState> jumpState;
    
    // 캐릭터 속성
    bool isGrounded = true;
    float horizontalInput = 0.0f;
    bool jumpPressed = false;
    
    Character() {
        // 상태 객체 초기화
        idleState = std::make_shared<IdleState>(this);
        walkState = std::make_shared<WalkState>(this);
        jumpState = std::make_shared<JumpState>(this);
        
        // 초기 상태 설정
        TransitionToState(idleState);
    }
    
    // 상태 전환 메서드
    void TransitionToState(std::shared_ptr<IState> newState) {
        if (currentState) {
            currentState->Exit();
        }
        
        currentState = newState;
        currentState->Enter();
        
        // 상태 변경 콜백 호출
        for (auto& callback : stateChangedCallbacks) {
            callback(currentState);
        }
    }
    
    // 상태 업데이트 메서드
    void Update() {
        if (currentState) {
            currentState->Execute();
        }
    }
    
    // 상태 변경 콜백 등록
    void AddStateChangedCallback(std::function<void(std::shared_ptr<IState>)> callback) {
        stateChangedCallbacks.push_back(callback);
    }
};

// 상태 클래스 구현
IdleState::IdleState(Character* character) : character(character) {}

void IdleState::Enter() {
    std::cout << "대기 상태 시작" << std::endl;
}

void IdleState::Execute() {
    // 대기 상태에서의 전환 조건 검사
    if (!character->isGrounded) {
        character->TransitionToState(character->jumpState);
        return;
    }
    
    if (std::abs(character->horizontalInput) > 0.1f) {
        character->TransitionToState(character->walkState);
        return;
    }
}

void IdleState::Exit() {
    std::cout << "대기 상태 종료" << std::endl;
}

WalkState::WalkState(Character* character) : character(character) {}

void WalkState::Enter() {
    std::cout << "걷기 상태 시작" << std::endl;
}

void WalkState::Execute() {
    // 걷기 상태에서의 전환 조건 검사
    if (!character->isGrounded) {
        character->TransitionToState(character->jumpState);
        return;
    }
    
    if (std::abs(character->horizontalInput) < 0.1f) {
        character->TransitionToState(character->idleState);
        return;
    }
    
    if (character->jumpPressed && character->isGrounded) {
        character->TransitionToState(character->jumpState);
        return;
    }
    
    // 걷기 로직 실행
    std::cout << "캐릭터가 " << character->horizontalInput << " 방향으로 걷는 중" << std::endl;
}

void WalkState::Exit() {
    std::cout << "걷기 상태 종료" << std::endl;
}

JumpState::JumpState(Character* character) : character(character) {}

void JumpState::Enter() {
    std::cout << "점프 상태 시작" << std::endl;
    // 점프 시작 로직
}

void JumpState::Execute() {
    // 점프 상태에서의 전환 조건 검사
    if (character->isGrounded) {
        if (std::abs(character->horizontalInput) > 0.1f) {
            character->TransitionToState(character->walkState);
        }
        else {
            character->TransitionToState(character->idleState);
        }
        return;
    }
    
    // 점프 중 로직 실행
    std::cout << "캐릭터가 점프 중" << std::endl;
}

void JumpState::Exit() {
    std::cout << "점프 상태 종료" << std::endl;
    character->jumpPressed = false;
}</code></pre>

                                <h3>4.2 사용 예시</h3>
                                <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;typeinfo&gt;

int main() {
    // 캐릭터 생성
    Character character;
    
    // 상태 변경 콜백 등록
    character.AddStateChangedCallback([](std::shared_ptr<IState> state) {
        std::cout << "상태 변경됨: " << typeid(*state).name() << std::endl;
    });
    
    // 대기 상태 시작 (초기 상태)
    std::cout << "\n--- 초기 상태(대기) ---" << std::endl;
    character.Update();
    
    // 걷기 상태로 전환
    std::cout << "\n--- 걷기 시작 ---" << std::endl;
    character.horizontalInput = 1.0f;
    character.Update();
    
    // 걷기 상태 유지
    std::cout << "\n--- 걷기 유지 ---" << std::endl;
    character.Update();
    
    // 점프 상태로 전환
    std::cout << "\n--- 점프 시작 ---" << std::endl;
    character.jumpPressed = true;
    character.isGrounded = false;
    character.Update();
    
    // 착지 후 대기 상태로 전환
    std::cout << "\n--- 착지(대기) ---" << std::endl;
    character.horizontalInput = 0.0f;
    character.isGrounded = true;
    character.Update();
    
    return 0;
}</code></pre>

                                <h3>4.3 계층적 상태 시스템 구현</h3>
                                <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;unordered_map&gt;
#include &lt;typeindex&gt;
#include &lt;typeinfo&gt;

// 상태 머신 클래스
class StateMachine {
private:
    std::unordered_map<std::type_index, std::shared_ptr<IState>> states;
    std::shared_ptr<IState> currentState;
    
public:
    // 상태 등록
    template<typename T>
    void RegisterState(std::shared_ptr<T> state) {
        states[std::type_index(typeid(T))] = state;
    }
    
    // 특정 타입의 상태로 전환
    template<typename T>
    void TransitionTo() {
        auto it = states.find(std::type_index(typeid(T)));
        if (it != states.end()) {
            if (currentState) {
                currentState->Exit();
            }
            currentState = it->second;
            currentState->Enter();
        }
    }
    
    // 상태 업데이트
    void Update() {
        if (currentState) {
            currentState->Execute();
        }
    }
};

// 전방 선언
class MovementState;

// 걷기 하위 상태
class WalkingSubState : public IState {
private:
    MovementState* parentState;
    
public:
    WalkingSubState(MovementState* parentState);
    
    void Enter() override;
    void Execute() override;
    void Exit() override;
};

// 달리기 하위 상태
class RunningSubState : public IState {
private:
    MovementState* parentState;
    
public:
    RunningSubState(MovementState* parentState);
    
    void Enter() override;
    void Execute() override;
    void Exit() override;
};

// 복합 상태 - 이동 상태
class MovementState : public IState {
protected:
    Character* character;
    StateMachine stateMachine;
    
public:
    MovementState(Character* character) : character(character) {
        // 하위 상태 등록
        stateMachine.RegisterState(std::make_shared<WalkingSubState>(this));
        stateMachine.RegisterState(std::make_shared<RunningSubState>(this));
    }
    
    void Enter() override {
        std::cout << "이동 상태 시작" << std::endl;
        
        // 기본 하위 상태 설정
        stateMachine.TransitionTo<WalkingSubState>();
    }
    
    void Execute() override {
        // 상위 상태에서의 전환 조건 검사
        if (!character->isGrounded) {
            character->TransitionToState(character->jumpState);
            return;
        }
        
        if (std::abs(character->horizontalInput) < 0.1f) {
            character->TransitionToState(character->idleState);
            return;
        }
        
        // 하위 상태 업데이트
        stateMachine.Update();
    }
    
    void Exit() override {
        std::cout << "이동 상태 종료" << std::endl;
    }
    
    // 달리기 전환 메서드
    void StartRunning() {
        stateMachine.TransitionTo<RunningSubState>();
    }
    
    // 걷기 전환 메서드
    void StartWalking() {
        stateMachine.TransitionTo<WalkingSubState>();
    }
    
    // character 게터
    Character* GetCharacter() const {
        return character;
    }
};

// 하위 상태 구현
WalkingSubState::WalkingSubState(MovementState* parentState) : parentState(parentState) {}

void WalkingSubState::Enter() {
    std::cout << "걷기 하위 상태 시작" << std::endl;
}

void WalkingSubState::Execute() {
    std::cout << "캐릭터가 걷는 중" << std::endl;
    
    // 달리기 상태로 전환 조건 검사
    Character* character = parentState->GetCharacter();
    if (std::abs(character->horizontalInput) > 0.8f) {
        parentState->StartRunning();
    }
}

void WalkingSubState::Exit() {
    std::cout << "걷기 하위 상태 종료" << std::endl;
}

RunningSubState::RunningSubState(MovementState* parentState) : parentState(parentState) {}

void RunningSubState::Enter() {
    std::cout << "달리기 하위 상태 시작" << std::endl;
}

void RunningSubState::Execute() {
    std::cout << "캐릭터가 달리는 중" << std::endl;
    
    // 걷기 상태로 전환 조건 검사
    Character* character = parentState->GetCharacter();
    if (std::abs(character->horizontalInput) <= 0.8f) {
        parentState->StartWalking();
    }
}

void RunningSubState::Exit() {
    std::cout << "달리기 하위 상태 종료" << std::endl;
}</code></pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="content-section">
                    <h2>5. State 패턴의 장단점</h2>
                    <div class="pattern-pros-cons">
                        <h3>5.1 장점</h3>
                        <ul>
                            <li>
                                <strong>단일 책임 원칙 준수</strong>
                                <p>각 상태와 관련된 코드를 별도 클래스로 분리하여 단일 책임 원칙을 충족시킵니다.</p>
                            </li>
                            <li>
                                <strong>개방/폐쇄 원칙 준수</strong>
                                <p>기존 코드를 수정하지 않고도 새 상태를 추가할 수 있어 확장성이 뛰어납니다.</p>
                            </li>
                            <li>
                                <strong>코드 구조와 가독성 향상</strong>
                                <p>복잡한 조건문이 제거되고 상태 동작이 명확하게 분리되어 코드의 가독성이 향상됩니다.</p>
                            </li>
                            <li>
                                <strong>상태 전환 로직 명확화</strong>
                                <p>상태 전환 조건과 프로세스가 명확하게 정의되어 있어 디버깅과 유지보수가 용이합니다.</p>
                            </li>
                        </ul>

                        <h3>5.2 단점</h3>
                        <ul>
                            <li>
                                <strong>클래스 수 증가</strong>
                                <p>각 상태마다 별도의 클래스가 필요하여 클래스 수가 증가할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>상태 간 데이터 공유 어려움</strong>
                                <p>상태 간에 데이터를 공유해야 하는 경우 컨텍스트 클래스를 통해 전달해야 하므로 설계가 복잡해질 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>상태가 적은 경우 오버헤드</strong>
                                <p>상태의 수가 적고 상태 전환이 단순한 경우, State 패턴을 적용하는 것이 불필요한 복잡성을 추가할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>상태 간 의존성</strong>
                                <p>상태 객체가 컨텍스트와 다른 상태에 대한 참조를 가져야 할 경우, 의존성이 증가하고 결합도가 높아질 수 있습니다.</p>
                            </li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>6. 주의사항 및 모범 사례</h2>
                    <div class="pattern-pros-cons">
                        <ul>
                            <li>
                                <strong>상태 전환 책임 명확화</strong>
                                <p>상태 전환의 책임이 상태 객체에 있는지, 컨텍스트에 있는지 명확히 정의하세요. 프로젝트의 일관성을 위해 한 가지 접근 방식을 선택하는 것이 좋습니다.</p>
                            </li>
                            <li>
                                <strong>상태 머신 구조화</strong>
                                <p>상태가 많고 복잡한 경우, 계층적 상태 머신을 고려하여 상태 관리를 구조화하세요. 이를 통해 상태 간의 관계와 전환을 더 명확하게 표현할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>메모리 관리</strong>
                                <p>많은 상태 객체를 생성하는 경우, 메모리 사용량에 주의하세요. 상황에 따라 객체 풀링이나 정적 인스턴스를 사용하는 것을 고려하세요.</p>
                            </li>
                            <li>
                                <strong>상태 디버깅 도구</strong>
                                <p>복잡한 상태 머신의 경우, 상태 전환과 현재 상태를 로깅하거나 시각화하는 도구를 개발하면 디버깅과 개발이 용이해집니다.</p>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2024 GameDev PatternHub. All rights reserved.</p>
        </div>
    </footer>

    <script src="../js/main.js"></script>
    <script>
        // 코드 하이라이팅 초기화
        document.addEventListener('DOMContentLoaded', (event) => {
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightBlock(block);
            });
        });

        // 언어 탭 전환
        const tabButtons = document.querySelectorAll('.tab-btn');
        const codeBlocks = document.querySelectorAll('.code-block');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const lang = button.getAttribute('data-lang');
                
                // 버튼 활성화 상태 변경
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                // 코드 블록 표시/숨김
                codeBlocks.forEach(block => {
                    block.classList.remove('active');
                    if (block.id === `${lang}-code`) {
                        block.classList.add('active');
                    }
                });
            });
        });
    </script>
</body>
</html>