<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MVVM 패턴 - GameDev PatternHub</title>
    <link rel="stylesheet" href="../css/common.css">
    <link rel="stylesheet" href="../css/layout.css">
    <link rel="stylesheet" href="../css/pattern-detail.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/csharp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js"></script>
</head>
<body>
    <header class="header">
        <nav class="nav-container">
            <div class="logo">
                <h1>GameDev PatternHub</h1>
            </div>
            <div class="nav-links">
                <a href="../index.html">홈</a>
                <a href="../patterns.html">패턴 목록</a>
                <a href="#">데모 게임</a>
                <a href="#">문서</a>
            </div>
            <button class="mobile-menu-btn">
                <i class="fas fa-bars"></i>
            </button>
        </nav>
    </header>

    <main class="pattern-detail">
        <section class="pattern-header">
            <div class="container">
                <h1>MVVM 패턴</h1>
                <div class="pattern-meta">
                    <span class="category">아키텍처 패턴</span>
                    <span class="difficulty">난이도: ★★★★☆</span>
                </div>
            </div>
        </section>

        <section class="pattern-content">
            <div class="container">
                <div class="content-section">
                    <h2>패턴 개요</h2>
                    <p>MVVM(Model-View-ViewModel) 패턴은 GUI 애플리케이션을 위한 아키텍처 패턴으로, 프레젠테이션 로직과 비즈니스 로직을 분리하여 유지보수성과 테스트 용이성을 향상시킵니다. 이 패턴은 Microsoft의 WPF와 Silverlight를 위해 개발되었으며, 현재는 다양한 플랫폼에서 UI 개발의 중요한 패턴으로 사용되고 있습니다.</p>
                    
                    <div class="pattern-benefits">
                        <h3>주요 장점</h3>
                        <ul>
                            <li>관심사 분리(Separation of Concerns)를 통한 코드 관리 용이성</li>
                            <li>데이터 바인딩을 통한 UI와 로직의 자동 동기화</li>
                            <li>ViewModel의 테스트 용이성</li>
                            <li>UI 디자이너와 개발자의 협업 효율성 증가</li>
                            <li>코드 재사용성 향상</li>
                        </ul>
                    </div>

                    <div class="pattern-use-cases">
                        <h3>사용 사례</h3>
                        <ul>
                            <li>게임 UI 시스템 (인벤토리, 스탯 화면, 퀘스트 창 등)</li>
                            <li>데이터 시각화가 필요한 복잡한 게임 화면</li>
                            <li>반응형 UI가 필요한 시스템</li>
                            <li>실시간으로 업데이트되는 게임 내 정보 표시</li>
                            <li>에디터 확장 기능 및 도구 개발</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>1. MVVM 패턴의 구성 요소</h2>
                    <p>MVVM 패턴은 다음과 같은 세 가지 주요 구성 요소로 이루어집니다:</p>
                    <div class="pattern-pros-cons">
                        <ul>
                            <li><strong>Model(모델)</strong> - 애플리케이션의 데이터와 비즈니스 로직을 담당합니다. 데이터의 저장, 처리, 갱신을 수행하며 ViewModel에 의존하지 않습니다.</li>
                            <li><strong>View(뷰)</strong> - 사용자에게 정보를 표시하고 입력을 ViewModel에 전달합니다. UI 요소(버튼, 슬라이더 등)를 포함하며 ViewModel과 데이터 바인딩됩니다.</li>
                            <li><strong>ViewModel(뷰모델)</strong> - View와 Model 사이의 중재자 역할을 합니다. Model의 데이터를 View에 표시하기 적합하게 가공하고, View의 입력을 받아 Model을 업데이트합니다.</li>
                        </ul>
                    </div>
                    <p>이러한 구성 요소들 간의 상호작용을 통해 UI와 비즈니스 로직이 분리되어 유지보수성과 테스트 용이성이 향상됩니다.</p>
                </div>

                <div class="content-section">
                    <h2>2. 왜 MVVM 패턴을 사용해야 하는가?</h2>
                    <div class="pattern-benefits">
                        <h3>2.1 관심사 분리</h3>
                        <p>UI, 비즈니스 로직, 데이터 처리를 분리하여 코드의 모듈성을 높이고 유지보수를 용이하게 합니다. 각 구성 요소가 담당하는 역할이 명확하게 구분됩니다.</p>
                        
                        <h3>2.2 데이터 바인딩</h3>
                        <p>View와 ViewModel 사이의 데이터 바인딩을 통해 자동으로 UI가 업데이트되므로, 수동으로 UI를 업데이트하는 코드를 줄일 수 있습니다.</p>
                        
                        <h3>2.3 테스트 용이성</h3>
                        <p>ViewModel은 View에 독립적이므로 단위 테스트가 용이합니다. UI 없이도 ViewModel의 로직을 검증할 수 있습니다.</p>
                        
                        <h3>2.4 코드 재사용성</h3>
                        <p>다양한 View가 동일한 ViewModel을 사용할 수 있어 코드 재사용성이 향상됩니다.</p>

                        <h3>2.5 디자이너-개발자 협업</h3>
                        <p>디자이너는 View에, 개발자는 ViewModel과 Model에 집중할 수 있어 협업 효율성이 증가합니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>3. 어떤 상황에서 사용해야 하는가?</h2>
                    <div class="pattern-use-cases">
                        <h3>3.1 복잡한 UI 시스템</h3>
                        <p>게임 내 인벤토리, 캐릭터 스탯 화면, 상점 시스템과 같이 복잡한 UI가 필요하고 데이터 표시와 사용자 입력 처리가 많은 경우에 적합합니다.</p>
                        
                        <h3>3.2 실시간 데이터 업데이트</h3>
                        <p>플레이어 체력, 경험치, 점수 등 게임 중 자주 변경되는 데이터를 UI에 실시간으로 반영해야 하는 경우에 유용합니다.</p>
                        
                        <h3>3.3 다양한 플랫폼 지원</h3>
                        <p>동일한 데이터를 다양한 형태의 UI로 표시해야 하는 경우, ViewModel을 재사용하여 여러 View를 지원할 수 있습니다.</p>
                        
                        <h3>3.4 테스트 중심 개발</h3>
                        <p>자동화된 테스트가 중요한 프로젝트에서 UI 로직을 테스트하기 쉽게 만들고자 할 때 유용합니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>4. 어떻게 구현하는가?</h2>
                    <div class="code-tabs">
                        <div class="tab-buttons">
                            <button class="tab-btn active" data-lang="csharp">C#</button>
                            <button class="tab-btn" data-lang="cpp">C++</button>
                        </div>
                        
                        <div class="tab-content">
                            <div class="code-block active" id="csharp-code">
                                <h3>4.1 Model 구현</h3>
                                <pre><code class="language-csharp">using System;

namespace MVVMPattern
{
    // Model: 데이터와 비즈니스 로직을 포함
    public class HealthModel
    {
        // 상수 정의
        private const int MinHealth = 0;
        private const int MaxHealth = 100;
        
        // 속성 및 필드
        private int _currentHealth;
        private string _playerName;
        
        // 이벤트 정의: 데이터 변경 시 ViewModel에 알림
        public event EventHandler<HealthChangedEventArgs> HealthChanged;
        
        // 속성
        public int CurrentHealth
        {
            get => _currentHealth;
            private set
            {
                if (_currentHealth == value) return;
                
                _currentHealth = value;
                // 값이 변경되면 이벤트 발생
                OnHealthChanged(new HealthChangedEventArgs(_currentHealth));
            }
        }
        
        public string PlayerName
        {
            get => _playerName;
            set
            {
                if (_playerName == value) return;
                _playerName = value;
            }
        }
        
        public int MinHealthValue => MinHealth;
        public int MaxHealthValue => MaxHealth;
        
        // 생성자
        public HealthModel(string playerName, int initialHealth = 100)
        {
            _playerName = playerName;
            _currentHealth = ClampHealth(initialHealth);
        }
        
        // 비즈니스 로직 메서드
        public void ApplyDamage(int amount)
        {
            if (amount < 0) throw new ArgumentException("Damage amount cannot be negative", nameof(amount));
            CurrentHealth = ClampHealth(CurrentHealth - amount);
        }
        
        public void Heal(int amount)
        {
            if (amount < 0) throw new ArgumentException("Heal amount cannot be negative", nameof(amount));
            CurrentHealth = ClampHealth(CurrentHealth + amount);
        }
        
        public void RestoreFullHealth()
        {
            CurrentHealth = MaxHealth;
        }
        
        // Helper 메서드
        private int ClampHealth(int health)
        {
            return Math.Clamp(health, MinHealth, MaxHealth);
        }
        
        // 이벤트 헬퍼 메서드
        protected virtual void OnHealthChanged(HealthChangedEventArgs e)
        {
            HealthChanged?.Invoke(this, e);
        }
    }
    
    // 이벤트 인자 클래스
    public class HealthChangedEventArgs : EventArgs
    {
        public int NewHealth { get; }
        
        public HealthChangedEventArgs(int newHealth)
        {
            NewHealth = newHealth;
        }
    }
}</code></pre>

                                <h3>4.2 ViewModel 구현</h3>
                                <pre><code class="language-csharp">using System;

namespace MVVMPattern
{
    // ViewModel: Model과 View 사이의 중재자 역할
    public class HealthViewModel : INotifyPropertyChanged
    {
        // INotifyPropertyChanged 인터페이스 구현
        public event PropertyChangedEventHandler PropertyChanged;
        
        // Model 참조
        private readonly HealthModel _model;
        
        // ViewModel의 속성들
        private int _healthValue;
        private string _healthStatus;
        private double _healthPercentage;
        private ConsoleColor _healthColor;
        
        // 명령(Command) 패턴 구현 - UI로부터 이벤트 수신
        public RelayCommand ApplyDamageCommand { get; }
        public RelayCommand HealCommand { get; }
        public RelayCommand RestoreCommand { get; }
        
        // View에 바인딩될 속성들
        public int HealthValue
        {
            get =&gt; _healthValue;
            private set
            {
                if (_healthValue == value) return;
                _healthValue = value;
                OnPropertyChanged(nameof(HealthValue));
            }
        }
        
        public string HealthStatus
        {
            get =&gt; _healthStatus;
            private set
            {
                if (_healthStatus == value) return;
                _healthStatus = value;
                OnPropertyChanged(nameof(HealthStatus));
            }
        }
        
        public double HealthPercentage
        {
            get =&gt; _healthPercentage;
            private set
            {
                if (Math.Abs(_healthPercentage - value) &lt; 0.001) return;
                _healthPercentage = value;
                OnPropertyChanged(nameof(HealthPercentage));
            }
        }
        
        public ConsoleColor HealthColor
        {
            get =&gt; _healthColor;
            private set
            {
                if (_healthColor == value) return;
                _healthColor = value;
                OnPropertyChanged(nameof(HealthColor));
            }
        }
        
        public string PlayerName =&gt; _model.PlayerName;
        
        // 생성자
        public HealthViewModel(HealthModel model)
        {
            _model = model ?? throw new ArgumentNullException(nameof(model));
            
            // Model 이벤트에 연결
            _model.HealthChanged += OnModelHealthChanged;
            
            // 커맨드 초기화
            ApplyDamageCommand = new RelayCommand(param =&gt; ApplyDamage(param));
            HealCommand = new RelayCommand(param =&gt; Heal(param));
            RestoreCommand = new RelayCommand(_ =&gt; RestoreHealth());
            
            // 초기값 설정
            UpdateHealth(_model.CurrentHealth);
        }
        
        // Model 이벤트 핸들러
        private void OnModelHealthChanged(object sender, HealthChangedEventArgs e)
        {
            UpdateHealth(e.NewHealth);
        }
        
        // 보조 메서드 - 속성 업데이트 및 변환
        private void UpdateHealth(int health)
        {
            HealthValue = health;
            HealthPercentage = (double)health / _model.MaxHealthValue;
            
            // 상태 텍스트 변환 로직
            HealthStatus = HealthPercentage switch
            {
                &gt;= 0.7 =&gt; &quot;Good&quot;,
                &gt;= 0.3 =&gt; &quot;Warning&quot;,
                _ =&gt; &quot;Danger&quot;
            };
            
            // 상태 색상 변환 로직
            HealthColor = HealthPercentage switch
            {
                &gt;= 0.7 =&gt; ConsoleColor.Green,
                &gt;= 0.3 =&gt; ConsoleColor.Yellow,
                _ =&gt; ConsoleColor.Red
            };
        }
        
        // 명령(Command) 처리 메서드
        private void ApplyDamage(object param)
        {
            if (param is int damage)
            {
                _model.ApplyDamage(damage);
            }
            else if (int.TryParse(param?.ToString(), out int damageValue))
            {
                _model.ApplyDamage(damageValue);
            }
            else
            {
                _model.ApplyDamage(10); // 기본값
            }
        }
        
        private void Heal(object param)
        {
            if (param is int healAmount)
            {
                _model.Heal(healAmount);
            }
            else if (int.TryParse(param?.ToString(), out int healValue))
            {
                _model.Heal(healValue);
            }
            else
            {
                _model.Heal(10); // 기본값
            }
        }
        
        private void RestoreHealth()
        {
            _model.RestoreFullHealth();
        }
        
        // INotifyPropertyChanged 구현
        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
        
        // 리소스 정리
        public void Dispose()
        {
            _model.HealthChanged -= OnModelHealthChanged;
        }
    }
    
    // 필요한 추가 클래스들
    
    // INotifyPropertyChanged - ViewModel이 View에 속성 변경을 알리는 인터페이스
    public interface INotifyPropertyChanged
    {
        event PropertyChangedEventHandler PropertyChanged;
    }
    
    public delegate void PropertyChangedEventHandler(object sender, PropertyChangedEventArgs e);
    
    public class PropertyChangedEventArgs : EventArgs
    {
        public string PropertyName { get; }
        
        public PropertyChangedEventArgs(string propertyName)
        {
            PropertyName = propertyName;
        }
    }
    
    // Command 패턴 구현 - UI에서 ViewModel의 메소드를 호출하기 위한 객체
    public class RelayCommand
    {
        private readonly Action&lt;object&gt; _execute;
        private readonly Func&lt;object, bool&gt; _canExecute;
        
        public RelayCommand(Action&lt;object&gt; execute, Func&lt;object, bool&gt; canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }
        
        public bool CanExecute(object parameter)
        {
            return _canExecute == null || _canExecute(parameter);
        }
        
        public void Execute(object parameter)
        {
            _execute(parameter);
        }
    }
}</code></pre>

                                <h3>4.3 View 구현 및 사용 예시</h3>
                                <pre><code class="language-csharp">using System;

namespace MVVMPattern
{
    // 간단한 콘솔 기반 View 구현
    public class HealthConsoleView
    {
        private readonly HealthViewModel _viewModel;
        
        public HealthConsoleView(HealthViewModel viewModel)
        {
            _viewModel = viewModel ?? throw new ArgumentNullException(nameof(viewModel));
            
            // ViewModel의 속성 변경 이벤트에 구독
            _viewModel.PropertyChanged += OnViewModelPropertyChanged;
            
            // 초기 렌더링
            RenderHealthInfo();
        }
        
        // ViewModel 속성 변경 이벤트 처리기
        private void OnViewModelPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            // 속성이 변경되면 화면을 다시 렌더링
            RenderHealthInfo();
        }
        
        // 화면 렌더링 메서드
        private void RenderHealthInfo()
        {
            Console.Clear();
            Console.WriteLine($"=== {_viewModel.PlayerName}의 건강 상태 ===");
            Console.WriteLine();
            
            // 상태 표시
            Console.ForegroundColor = _viewModel.HealthColor;
            Console.WriteLine($"건강 상태: {_viewModel.HealthStatus}");
            Console.WriteLine($"체력: {_viewModel.HealthValue}/100 ({_viewModel.HealthPercentage:P0})");
            Console.ResetColor();
            
            // 체력바 표시
            DrawHealthBar(_viewModel.HealthPercentage, 50);
            
            Console.WriteLine();
            Console.WriteLine("명령어:");
            Console.WriteLine("1. 대미지 입히기 (10)\n2. 치유하기 (10)\n3. 체력 회복\n0. 종료");
        }
        
        // 체력바 그리기 헬퍼 메서드
        private void DrawHealthBar(double percentage, int width)
        {
            int filledWidth = (int)(percentage * width);
            
            Console.Write("[");
            Console.ForegroundColor = _viewModel.HealthColor;
            
            for (int i = 0; i < width; i++)
            {
                if (i < filledWidth)
                    Console.Write("█");
                else
                    Console.Write(" ");
            }
            
            Console.ResetColor();
            Console.WriteLine("]");
        }
        
        // 사용자 입력 처리
        public void HandleUserInput()
        {
            bool exit = false;
            
            while (!exit)
            {
                var key = Console.ReadKey(true).KeyChar;
                
                switch (key)
                {
                    case '1':
                        _viewModel.ApplyDamageCommand.Execute(10);
                        break;
                    case '2':
                        _viewModel.HealCommand.Execute(10);
                        break;
                    case '3':
                        _viewModel.RestoreCommand.Execute(null);
                        break;
                    case '0':
                        exit = true;
                        break;
                }
            }
        }
        
        // 리소스 정리
        public void Dispose()
        {
            _viewModel.PropertyChanged -= OnViewModelPropertyChanged;
        }
    }
    
    // 프로그램 실행 예제
    public class Program
    {
        public static void Main(string[] args)
        {
            // 1. Model 생성
            var healthModel = new HealthModel("플레이어", 100);
            
            // 2. ViewModel 생성 및 Model 연결
            var viewModel = new HealthViewModel(healthModel);
            
            // 3. View 생성 및 ViewModel 연결
            var view = new HealthConsoleView(viewModel);
            
            // 4. 사용자 입력 처리 시작
            view.HandleUserInput();
            
            // 5. 정리
            view.Dispose();
            viewModel.Dispose();
        }
    }
}</code></pre>
                            </div>

                            <div class="code-block" id="cpp-code">
                                <h3>4.1 Model 구현</h3>
                                <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;algorithm&gt;

namespace MVVMPattern {

    // 이벤트 인자 클래스
    class HealthChangedEventArgs {
    private:
        int _newHealth;

    public:
        explicit HealthChangedEventArgs(int newHealth) : _newHealth(newHealth) {}

        int getNewHealth() const { return _newHealth; }
    };

    // 이벤트 핸들러 타입
    using HealthChangedEventHandler = std::function<void(const HealthChangedEventArgs&)>;

    // Model: 데이터와 비즈니스 로직을 포함
    class HealthModel {
    private:
        // 상수 정의
        static constexpr int MIN_HEALTH = 0;
        static constexpr int MAX_HEALTH = 100;
        
        // 데이터 필드
        int _currentHealth;
        std::string _playerName;
        
        // 이벤트 수신자 목록
        std::vector<HealthChangedEventHandler> _healthChangedHandlers;
        
        // 값을 유효한 범위로 조정
        int clampHealth(int health) const {
            return std::clamp(health, MIN_HEALTH, MAX_HEALTH);
        }
        
    public:
        // 생성자
        HealthModel(const std::string& playerName, int initialHealth = 100)
            : _playerName(playerName), _currentHealth(clampHealth(initialHealth)) {}
        
        // 속성 가져오기
        int getCurrentHealth() const { return _currentHealth; }
        
        void setCurrentHealth(int value) {
            int newValue = clampHealth(value);
            if (_currentHealth != newValue) {
                _currentHealth = newValue;
                // 이벤트 발생
                HealthChangedEventArgs args(_currentHealth);
                for (const auto& handler : _healthChangedHandlers) {
                    handler(args);
                }
            }
        }
        
        std::string getPlayerName() const { return _playerName; }
        void setPlayerName(const std::string& name) { _playerName = name; }
        
        static int getMinHealth() { return MIN_HEALTH; }
        static int getMaxHealth() { return MAX_HEALTH; }
        
        // 이벤트 핸들러 등록
        void addHealthChangedHandler(const HealthChangedEventHandler& handler) {
            _healthChangedHandlers.push_back(handler);
        }
        
        void removeHealthChangedHandler(const HealthChangedEventHandler& handler) {
            // 해당 핸들러를 제거하는 로직 (예시용 단순화)
            _healthChangedHandlers.clear();
        }
        
        // 비즈니스 로직 메서드
        void applyDamage(int amount) {
            if (amount < 0) {
                throw std::invalid_argument("Damage amount cannot be negative");
            }
            setCurrentHealth(_currentHealth - amount);
        }
        
        void heal(int amount) {
            if (amount < 0) {
                throw std::invalid_argument("Heal amount cannot be negative");
            }
            setCurrentHealth(_currentHealth + amount);
        }
        
        void restoreFullHealth() {
            setCurrentHealth(MAX_HEALTH);
        }
    };

}</code></pre>

                                <h3>4.2 ViewModel 구현</h3>
                                <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;algorithm&gt;

namespace MVVMPattern {

    // PropertyChangedEventArgs 클래스
    class PropertyChangedEventArgs {
    private:
        std::string _propertyName;

    public:
        explicit PropertyChangedEventArgs(const std::string& propertyName)
            : _propertyName(propertyName) {}

        std::string getPropertyName() const { return _propertyName; }
    };

    // 이벤트 핸들러 타입
    using PropertyChangedEventHandler = std::function<void(const PropertyChangedEventArgs&)>;
    
    // Command 클래스 - View에서 ViewModel의 메서드를 호출하기 위한 객체
    class RelayCommand {
    private:
        std::function<void(int)> _execute;
        std::function<bool(int)> _canExecute;
        
    public:
        RelayCommand(std::function<void(int)> execute, std::function<bool(int)> canExecute = nullptr)
            : _execute(std::move(execute)), _canExecute(std::move(canExecute)) {}
        
        bool canExecute(int parameter) const {
            return _canExecute == nullptr || _canExecute(parameter);
        }
        
        void execute(int parameter) const {
            if (canExecute(parameter)) {
                _execute(parameter);
            }
        }
    };
    
    // 색상 정의 (예시용)
    enum class ConsoleColor {
        Black, Red, Green, Yellow, Blue, Magenta, Cyan, White, Default
    };
    
    // ViewModel: Model과 View 사이의 중재자 역할
    class HealthViewModel {
    private:
        // Model 참조
        std::shared_ptr<HealthModel> _model;
        
        // ViewModel의 속성들
        int _healthValue;
        std::string _healthStatus;
        double _healthPercentage;
        ConsoleColor _healthColor;
        
        // 이벤트 수신자 목록
        std::vector<PropertyChangedEventHandler> _propertyChangedHandlers;
        
        // Model 이벤트 핸들러
        void onModelHealthChanged(const HealthChangedEventArgs& e) {
            updateHealth(e.getNewHealth());
        }
        
        // 보조 메서드
        void updateHealth(int health) {
            _healthValue = health;
            _healthPercentage = static_cast<double>(health) / _model->getMaxHealth();
            
            // 상태 텍스트 변환 로직
            if (_healthPercentage >= 0.7) {
                _healthStatus = "Good";
                _healthColor = ConsoleColor::Green;
            } else if (_healthPercentage >= 0.3) {
                _healthStatus = "Warning";
                _healthColor = ConsoleColor::Yellow;
            } else {
                _healthStatus = "Danger";
                _healthColor = ConsoleColor::Red;
            }
            
            // 속성 변경 알림
            onPropertyChanged("HealthValue");
            onPropertyChanged("HealthStatus");
            onPropertyChanged("HealthPercentage");
            onPropertyChanged("HealthColor");
        }
        
        // INotifyPropertyChanged 구현
        void onPropertyChanged(const std::string& propertyName) {
            PropertyChangedEventArgs args(propertyName);
            for (const auto& handler : _propertyChangedHandlers) {
                handler(args);
            }
        }
        
    public:
        // 생성자
        explicit HealthViewModel(std::shared_ptr<HealthModel> model)
            : _model(std::move(model)) {
            
            // Model 이벤트에 연결
            _model->addHealthChangedHandler([this](const HealthChangedEventArgs& e) {
                this->onModelHealthChanged(e);
            });
            
            // 초기값 설정
            updateHealth(_model->getCurrentHealth());
        }
        
        // 소멸자
        ~HealthViewModel() {
            // 이벤트 핸들러 제거
            _model->removeHealthChangedHandler([](const HealthChangedEventArgs&) {});
        }
        
        // 가져오기 속성들
        int getHealthValue() const { return _healthValue; }
        std::string getHealthStatus() const { return _healthStatus; }
        double getHealthPercentage() const { return _healthPercentage; }
        ConsoleColor getHealthColor() const { return _healthColor; }
        std::string getPlayerName() const { return _model->getPlayerName(); }
        
        // 명령 메서드
        RelayCommand createDamageCommand() {
            return RelayCommand([this](int amount) { this->applyDamage(amount); });
        }
        
        RelayCommand createHealCommand() {
            return RelayCommand([this](int amount) { this->heal(amount); });
        }
        
        RelayCommand createRestoreCommand() {
            return RelayCommand([this](int) { this->restoreHealth(); });
        }
        
        // 명령 처리 메서드
        void applyDamage(int amount) {
            _model->applyDamage(amount > 0 ? amount : 10); // 기본값 10
        }
        
        void heal(int amount) {
            _model->heal(amount > 0 ? amount : 10); // 기본값 10
        }
        
        void restoreHealth() {
            _model->restoreFullHealth();
        }
        
        // 이벤트 핸들러 추가
        void addPropertyChangedHandler(const PropertyChangedEventHandler& handler) {
            _propertyChangedHandlers.push_back(handler);
        }
        
        void removePropertyChangedHandler(const PropertyChangedEventHandler& handler) {
            // 해당 핸들러를 제거하는 로직 (예시용 단순화)
            _propertyChangedHandlers.clear();
        }
    };

}</code></pre>

                                <h3>4.3 View 구현 및 사용 예시</h3>
                                <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;

namespace MVVMPattern {

    // 콘솔 관련 포맷팅 헬퍼 함수
    void setConsoleColor(ConsoleColor color) {
        switch (color) {
            case ConsoleColor::Red: std::cout << "\033[31m"; break;
            case ConsoleColor::Green: std::cout << "\033[32m"; break;
            case ConsoleColor::Yellow: std::cout << "\033[33m"; break;
            case ConsoleColor::Default: std::cout << "\033[0m"; break;
            default: std::cout << "\033[0m"; break;
        }
    }

    void resetConsoleColor() {
        std::cout << "\033[0m";
    }

    // 콘솔 기반 View 구현
    class HealthConsoleView {
    private:
        std::shared_ptr<HealthViewModel> _viewModel;
        RelayCommand _damageCommand;
        RelayCommand _healCommand;
        RelayCommand _restoreCommand;
        
        // ViewModel 속성 변경 이벤트 처리기
        void onViewModelPropertyChanged(const PropertyChangedEventArgs& e) {
            // 속성이 변경되면 화면을 다시 렌더링
            renderHealthInfo();
        }
        
        // 화면 렌더링
        void renderHealthInfo() {
            system("cls");  // 화면 지우기 (Windows)
            // system("clear"); // 화면 지우기 (Linux/Mac)
            
            std::cout << "=== " << _viewModel->getPlayerName() << "의 건강 상태 ===" << std::endl;
            std::cout << std::endl;
            
            // 상태 표시
            setConsoleColor(_viewModel->getHealthColor());
            std::cout << "건강 상태: " << _viewModel->getHealthStatus() << std::endl;
            std::cout << "체력: " << _viewModel->getHealthValue() << "/100 (" 
                << (_viewModel->getHealthPercentage() * 100) << "%)" << std::endl;
            resetConsoleColor();
            
            // 체력바 표시
            drawHealthBar(_viewModel->getHealthPercentage(), 50);
            
            std::cout << std::endl;
            std::cout << "명령어:" << std::endl;
            std::cout << "1. 대미지 입히기 (10)" << std::endl;
            std::cout << "2. 치유하기 (10)" << std::endl;
            std::cout << "3. 체력 회복" << std::endl;
            std::cout << "0. 종료" << std::endl;
        }
        
        // 헬퍼 메서드 - 체력바 그리기
        void drawHealthBar(double percentage, int width) {
            int filledWidth = static_cast<int>(percentage * width);
            
            std::cout << "[";
            setConsoleColor(_viewModel->getHealthColor());
            
            for (int i = 0; i < width; i++) {
                if (i < filledWidth)
                    std::cout << "#";
                else
                    std::cout << " ";
            }
            
            resetConsoleColor();
            std::cout << "]" << std::endl;
        }
        
    public:
        // 생성자
        explicit HealthConsoleView(std::shared_ptr<HealthViewModel> viewModel)
            : _viewModel(std::move(viewModel)) {
            
            // ViewModel의 속성 변경 이벤트에 구독
            _viewModel->addPropertyChangedHandler([this](const PropertyChangedEventArgs& e) {
                this->onViewModelPropertyChanged(e);
            });
            
            // 커맨드 초기화
            _damageCommand = _viewModel->createDamageCommand();
            _healCommand = _viewModel->createHealCommand();
            _restoreCommand = _viewModel->createRestoreCommand();
            
            // 초기 렌더링
            renderHealthInfo();
        }
        
        // 소멸자
        ~HealthConsoleView() {
            // 이벤트 핸들러 제거
            _viewModel->removePropertyChangedHandler([](const PropertyChangedEventArgs&) {});
        }
        
        // 사용자 입력 처리
        void handleUserInput() {
            bool exit = false;
            
            while (!exit) {
                char key;
                std::cin >> key;
                
                switch (key) {
                    case '1':
                        _damageCommand.execute(10);
                        break;
                    case '2':
                        _healCommand.execute(10);
                        break;
                    case '3':
                        _restoreCommand.execute(0);
                        break;
                    case '0':
                        exit = true;
                        break;
                }
            }
        }
    };

    // 예제 실행
    void runExample() {
        // 1. Model 생성
        auto healthModel = std::make_shared<HealthModel>("플레이어", 100);
        
        // 2. ViewModel 생성 및 Model 연결
        auto viewModel = std::make_shared<HealthViewModel>(healthModel);
        
        // 3. View 생성 및 ViewModel 연결
        auto view = std::make_shared<HealthConsoleView>(viewModel);
        
        // 4. 사용자 입력 처리 시작
        view->handleUserInput();
        
        // 5. 자동 정리 (실제로는 스코프를 나갈 때 자동으로 정리됨)
    }
}

// 메인 함수 예시
int main() {
    MVVMPattern::runExample();
    return 0;
}</code></pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="content-section">
                    <h2>5. MVVM 패턴의 장단점</h2>
                    <div class="pattern-pros-cons">
                        <h3>5.1 장점</h3>
                        <ul>
                            <li>
                                <strong>관심사 분리</strong>
                                <p>UI, 비즈니스 로직, 데이터 처리가 분리되어 코드의 모듈성과 유지보수성이 향상됩니다.</p>
                            </li>
                            <li>
                                <strong>데이터 바인딩을 통한 자동 UI 업데이트</strong>
                                <p>데이터가 변경되면 자동으로 UI가 업데이트되어 코드량이 줄고 UI 업데이트 관련 버그가 감소합니다.</p>
                            </li>
                            <li>
                                <strong>테스트 용이성</strong>
                                <p>ViewModel이 View에 독립적이므로 단위 테스트가 쉬워집니다.</p>
                            </li>
                            <li>
                                <strong>코드 재사용성</strong>
                                <p>ViewModel은 여러 View에서 재사용할 수 있어 코드 중복이 줄어듭니다.</p>
                            </li>
                        </ul>

                        <h3>5.2 단점</h3>
                        <ul>
                            <li>
                                <strong>학습 곡선</strong>
                                <p>데이터 바인딩과 MVVM 개념을 이해하는 데 시간이 필요할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>단순한 UI에는 과도할 수 있음</strong>
                                <p>간단한 UI에 MVVM을 적용하면 불필요한 복잡성이 증가할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>메모리 사용량 증가</strong>
                                <p>데이터 바인딩과 추가 레이어로 인해 메모리 사용량이 증가할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>디버깅 복잡성</strong>
                                <p>데이터 바인딩으로 인해 데이터 흐름을 추적하기 어려울 수 있습니다.</p>
                            </li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>6. MVVM vs 다른 패턴</h2>
                    <div class="pattern-comparison">
                        <h3>6.1 MVVM vs MVC (Model-View-Controller)</h3>
                        <p>MVC에서는 Controller가 View와 Model 간의 중재자 역할을 하며, 사용자 입력을 직접 처리합니다. MVVM에서는 ViewModel이 중재자 역할을 하지만, 데이터 바인딩을 통해 View와 통신하므로 View의 업데이트 코드가 줄어듭니다.</p>
                        
                        <h3>6.2 MVVM vs MVP (Model-View-Presenter)</h3>
                        <p>MVP에서는 Presenter가 View와 Model 사이의 중재자 역할을 하며, View와 1:1 관계를 가집니다. MVVM에서는 데이터 바인딩을 통해 ViewModel과 View가 느슨하게 결합되어 있어 코드 재사용성이 더 높습니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>7. 주의사항 및 모범 사례</h2>
                    <div class="pattern-pros-cons">
                        <ul>
                            <li>
                                <strong>ViewModel은 View에 대해 알지 말아야 함</strong>
                                <p>ViewModel은 특정 View에 의존하지 않도록 설계하여 재사용성을 높이고 테스트를 용이하게 해야 합니다.</p>
                            </li>
                            <li>
                                <strong>Command 패턴 활용</strong>
                                <p>사용자 입력 처리를 위해 Command 패턴을 활용하여 View와 ViewModel 간의 상호작용을 체계화할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>필요한 경우에만 적용</strong>
                                <p>단순한 UI에는 MVVM이 과도할 수 있으므로, UI의 복잡성에 따라 적절한 패턴을 선택해야 합니다.</p>
                            </li>
                            <li>
                                <strong>메모리 누수 주의</strong>
                                <p>데이터 바인딩으로 인한 순환 참조가 발생하지 않도록 약한 참조(Weak Reference)를 활용하세요.</p>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2024 GameDev PatternHub. All rights reserved.</p>
        </div>
    </footer>

    <script src="../js/main.js"></script>
    <script>
        // 코드 하이라이팅 초기화
        document.addEventListener('DOMContentLoaded', (event) => {
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightBlock(block);
            });
        });

        // 언어 탭 전환
        const tabButtons = document.querySelectorAll('.tab-btn');
        const codeBlocks = document.querySelectorAll('.code-block');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const lang = button.getAttribute('data-lang');
                
                // 버튼 활성화 상태 변경
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                // 코드 블록 표시/숨김
                codeBlocks.forEach(block => {
                    block.classList.remove('active');
                    if (block.id === `${lang}-code`) {
                        block.classList.add('active');
                    }
                });
            });
        });
    </script>
</body>
</html>