<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dirty Flag 패턴 - GameDev PatternHub</title>
    <link rel="stylesheet" href="../css/common.css">
    <link rel="stylesheet" href="../css/layout.css">
    <link rel="stylesheet" href="../css/pattern-detail.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <header class="header">
        <nav class="nav-container">
            <div class="logo">
                <h1>GameDev PatternHub</h1>
            </div>
            <div class="nav-links">
                <a href="../index.html">홈</a>
                <a href="../patterns.html">패턴 목록</a>
                <a href="#">데모 게임</a>
                <a href="#">문서</a>
                <button id="theme-toggle" class="theme-toggle" aria-label="다크 모드 전환">
                    <i class="fas fa-moon"></i>
                </button>
            </div>
            <button class="mobile-menu-btn">
                <i class="fas fa-bars"></i>
            </button>
        </nav>
    </header>

    <main class="pattern-detail">
        <section class="pattern-header">
            <div class="container">
                <h1>Dirty Flag 패턴</h1>
                <div class="pattern-meta">
                    <span class="category">행동 패턴</span>
                    <span class="difficulty">난이도: ★★☆☆☆</span>
                </div>
            </div>
        </section>

        <section class="pattern-content">
            <div class="container">
                <div class="content-section">
                    <h2>패턴 개요</h2>
                    <p>Dirty Flag 패턴은 객체의 상태가 변경되었을 때 이를 표시하고, 필요한 경우에만 업데이트 연산을 수행하도록 하는 최적화 패턴입니다. 게임 개발에서는 리소스 집약적인 계산이나 렌더링 작업을 최소화하기 위해 널리 사용됩니다.</p>
                    
                    <div class="pattern-benefits">
                        <h3>주요 장점</h3>
                        <ul>
                            <li>불필요한 연산 방지로 성능 향상</li>
                            <li>연산이 필요한 객체만 선택적으로 업데이트</li>
                            <li>복잡한 시스템에서 상태 변경 추적 용이</li>
                            <li>메모리나 CPU 집약적인 연산의 최적화</li>
                        </ul>
                    </div>

                    <div class="pattern-use-cases">
                        <h3>사용 사례</h3>
                        <ul>
                            <li>게임 월드의 동적 로딩 및 언로딩</li>
                            <li>물리 시뮬레이션에서 변경된 객체만 업데이트</li>
                            <li>GUI 시스템에서 변경된 요소만 다시 그리기</li>
                            <li>게임 상태 저장 시 변경된 데이터만 저장</li>
                            <li>네트워크 동기화에서 변경된 데이터만 전송</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>1. Dirty Flag 패턴의 기본 개념</h2>
                    <p>Dirty Flag 패턴의 핵심은 다음과 같습니다:</p>
                    <div class="pattern-pros-cons">
                        <ul>
                            <li>객체의 상태가 변경되었을 때 'dirty' 플래그를 설정</li>
                            <li>필요한 시점에 dirty 플래그가 설정된 객체만 업데이트 수행</li>
                            <li>업데이트 후 dirty 플래그를 초기화(clean)</li>
                            <li>변경되지 않은 객체에 대한 불필요한 처리 회피</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>2. 왜 Dirty Flag 패턴을 사용해야 하는가?</h2>
                    <div class="pattern-benefits">
                        <h3>2.1 성능 최적화</h3>
                        <p>게임에서는 많은 객체들이 매 프레임마다 업데이트되어야 합니다. Dirty Flag 패턴을 사용하면 변경된 객체만 선택적으로 업데이트하여 CPU와 메모리 리소스를 절약할 수 있습니다.</p>
                        
                        <h3>2.2 효율적인 리소스 관리</h3>
                        <p>특히 리소스 집약적인 작업(예: 텍스처 업데이트, 경로 계산, 물리 시뮬레이션)에서 모든 객체를 매번 업데이트하는 것은 비효율적입니다. Dirty Flag를 사용하면 필요한 객체만 업데이트할 수 있습니다.</p>
                        
                        <h3>2.3 상태 변경 추적</h3>
                        <p>복잡한 게임 시스템에서 어떤 객체의 상태가 변경되었는지 추적하기 어려울 수 있습니다. Dirty Flag는 상태 변경을 명시적으로 표시하여 추적을 용이하게 합니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>3. 어떤 상황에서 사용해야 하는가?</h2>
                    <div class="pattern-use-cases">
                        <h3>3.1 동적 레벨 로딩</h3>
                        <p>플레이어 주변의 게임 월드 섹터만 로드하고 다른 부분은 언로드하여 메모리 사용을 최적화할 때 유용합니다.</p>
                        
                        <h3>3.2 렌더링 최적화</h3>
                        <p>변경된 객체나 화면의 특정 부분만 다시 렌더링하여 GPU 사용을 최소화할 수 있습니다.</p>
                        
                        <h3>3.3 물리 시뮬레이션</h3>
                        <p>움직이거나 상호작용하는 객체만 물리 계산을 수행하고 정적인 객체는 건너뛰어 성능을 향상시킵니다.</p>
                        
                        <h3>3.4 네트워크 동기화</h3>
                        <p>멀티플레이어 게임에서 변경된 데이터만 네트워크로 전송하여 대역폭 사용을 최적화합니다.</p>
                    </div>
                </div>

                <div class="content-section">
                    <h2>4. 어떻게 구현하는가?</h2>
                    <p>Dirty Flag 패턴의 구현은 다양한 언어로 가능합니다. 아래 링크를 통해 각 언어별 구현 코드를 확인할 수 있습니다.</p>
                    
                    <div class="code-tabs">
                        <div class="code-language-buttons">
                            <a href="codes/dirtyflag_csharp.html" class="code-language-btn">C# 코드 보기 <i class="fas fa-code"></i></a>
                            <a href="codes/dirtyflag_cpp.html" class="code-language-btn">C++ 코드 보기 <i class="fas fa-code"></i></a>
                        </div>
                    </div>
                </div>

                <div class="content-section">
                    <h2>5. Dirty Flag 패턴의 장단점</h2>
                    <div class="pattern-pros-cons">
                        <h3>5.1 장점</h3>
                        <ul>
                            <li>
                                <strong>성능 향상</strong>
                                <p>필요한 객체만 선택적으로 업데이트하여 CPU와 메모리 사용을 최적화합니다.</p>
                            </li>
                            <li>
                                <strong>리소스 효율성</strong>
                                <p>변경되지 않은 객체에 대한 불필요한 처리를 방지하여 리소스를 절약합니다.</p>
                            </li>
                            <li>
                                <strong>명확한 상태 관리</strong>
                                <p>객체의 상태 변경을 명시적으로 표시하여 코드의 가독성과 관리성을 향상시킵니다.</p>
                            </li>
                        </ul>

                        <h3>5.2 단점</h3>
                        <ul>
                            <li>
                                <strong>추가적인 상태 관리</strong>
                                <p>dirty 플래그를 관리하기 위한 추가 코드가 필요하며, 이로 인해 코드 복잡성이 증가할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>플래그 관리 오류</strong>
                                <p>플래그를 적절히 설정하거나 초기화하지 않으면 업데이트가 누락되거나 불필요한 업데이트가 발생할 수 있습니다.</p>
                            </li>
                            <li>
                                <strong>디버깅 어려움</strong>
                                <p>상태 변경 추적이 복잡해질 수 있어 디버깅이 어려워질 수 있습니다.</p>
                            </li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h2>6. 주의사항 및 모범 사례</h2>
                    <div class="pattern-pros-cons">
                        <ul>
                            <li>
                                <strong>명확한 책임 할당</strong>
                                <p>객체가 자신의 dirty 플래그를 설정하고 다른 객체가 이를 확인하고 업데이트하는 책임을 명확히 구분하세요.</p>
                            </li>
                            <li>
                                <strong>상태 변경 일관성</strong>
                                <p>상태가 변경될 때마다 항상 dirty 플래그를 설정하도록 일관된 규칙을 유지하세요.</p>
                            </li>
                            <li>
                                <strong>필요한 곳에만 적용</strong>
                                <p>모든 객체에 Dirty Flag를 적용하면 오히려 오버헤드가 발생할 수 있습니다. 업데이트 비용이 큰 객체에 선택적으로 적용하세요.</p>
                            </li>
                            <li>
                                <strong>의존성 고려</strong>
                                <p>객체 간 의존성이 있는 경우, 한 객체의 변경이 다른 객체에도 영향을 미칠 수 있으므로 이를 고려한 설계가 필요합니다.</p>
                            </li>
                        </ul>
                    </div>
                </div>
                
                <div class="content-section">
                    <h2>7. 게임 개발에서의 Dirty Flag 패턴 응용</h2>
                    <div class="pattern-pros-cons">
                        <h3>7.1 렌더링 최적화</h3>
                        <p>3D 모델이나 텍스처 데이터가 변경된 경우에만 GPU로 데이터를 전송하고 그렇지 않으면 이전 프레임의 데이터를 재사용합니다.</p>
                        
                        <h3>7.2 물리 시뮬레이션</h3>
                        <p>게임 내 물체가 움직이거나 상호작용하는 경우에만 물리 계산을 수행하여 CPU 사용량을 최적화합니다.</p>
                        
                        <h3>7.3 사용자 인터페이스</h3>
                        <p>UI 요소의 내용이나 위치가 변경된 경우에만 다시 그리기 작업을 수행하여 렌더링 오버헤드를 줄입니다.</p>
                        
                        <h3>7.4 게임 저장 시스템</h3>
                        <p>변경된 데이터만 저장하여 디스크 I/O 작업을 최소화하고 저장 파일의 크기를 줄입니다.</p>
                    </div>
                </div>
                
                <div class="navigation-buttons">
                    <a href="../patterns.html" class="back-button"><i class="fas fa-arrow-left"></i> 패턴 목록으로 돌아가기</a>
                    <a href="codes/dirtyflag_csharp.html" class="next-button">C# 코드 예제 보기 <i class="fas fa-arrow-right"></i></a>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2025 GameDev PatternHub. All rights reserved.</p>
        </div>
    </footer>

    <script src="../js/main.js"></script>
</body>
</html>