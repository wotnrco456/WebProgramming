{
  "id": "command",
  "title": "Command 패턴",
  "meta": {
    "category": "행동 패턴",
    "difficulty": "난이도: ★★★☆☆"
  },
  "sections": [
    {
      "id": "overview",
      "title": "패턴 개요",
      "content": "Command 패턴은 요청을 객체로 캡슐화하여 클라이언트와 수신자 간의 의존성을 분리하고, 요청을 큐에 저장하거나 로그로 기록하며, 작업의 취소(undo)와 재실행(redo)을 지원할 수 있게 하는 행동 디자인 패턴입니다. 게임 개발에서는 사용자 입력 처리, 행동 시스템, 히스토리 관리 등에 널리 사용됩니다.",
      "benefits": [
        "작업 실행과 호출을 분리하여 코드의 유연성 향상",
        "작업의 취소(undo)와 재실행(redo) 기능 구현 용이",
        "복잡한 작업을 간단한 작업들로 분해 가능",
        "명령 큐를 통한 지연 실행 및 스케줄링 지원",
        "히스토리 추적 및 로깅 기능 구현 가능"
      ],
      "useCases": [
        "게임 내 사용자 입력 및 액션 시스템 구현",
        "취소/재실행 기능이 필요한 에디터 도구 개발",
        "턴 기반 게임의 플레이어 행동 관리",
        "AI 행동 시스템 구현",
        "매크로 및 복합 명령 생성",
        "네트워크 게임에서의 행동 직렬화 및 재생"
      ]
    },
    {
      "id": "basic-concept",
      "title": "1. Command 패턴의 기본 개념",
      "content": "Command 패턴의 핵심 구성 요소는 다음과 같습니다:",
      "benefits": [
        "Command 인터페이스 - 명령을 실행하고 취소하는 메서드를 선언",
        "ConcreteCommand - Command 인터페이스를 구현한 실제 명령 클래스",
        "Invoker(호출자) - 명령 실행을 요청하는 클래스",
        "Receiver(수신자) - 명령이 실행될 때 실제 작업을 수행하는 클래스",
        "Client(클라이언트) - Command 객체를 생성하고 Invoker에 연결하는 클래스"
      ]
    },
    {
      "id": "why",
      "title": "2. 왜 Command 패턴을 사용해야 하는가?",
      "benefits": [
        {
          "title": "2.1 행동의 캡슐화",
          "description": "게임에서 수행할 모든 작업을 독립적인 객체로 캡슐화함으로써 코드의 모듈화와 재사용성을 높입니다. 이를 통해 다양한 컨텍스트에서 동일한 작업을 쉽게 호출할 수 있습니다."
        },
        {
          "title": "2.2 작업의 취소/재실행 지원",
          "description": "각 Command 객체가 실행 및 취소 로직을 포함할 수 있어, 작업의 취소(Undo)와 재실행(Redo) 기능을 쉽게 구현할 수 있습니다. 게임 내 전략적 의사결정이나 에디터 도구에 매우 유용합니다."
        },
        {
          "title": "2.3 지연 실행 및 큐잉",
          "description": "명령을 즉시 실행하지 않고 저장했다가 나중에 실행할 수 있어, 명령 큐나 스케줄러 시스템을 쉽게 구현할 수 있습니다. 이는 턴 기반 게임이나 작업 스케줄링에 유용합니다."
        },
        {
          "title": "2.4 매크로 및 복합 명령",
          "description": "여러 명령을 하나의 명령으로 조합하여 복잡한 작업을 단순화할 수 있습니다. 이를 통해 매크로 기능이나 AI 행동 패턴을 쉽게 구현할 수 있습니다."
        }
      ]
    },
    {
      "id": "when",
      "title": "3. 어떤 상황에서 사용해야 하는가?",
      "useCases": [
        {
          "title": "3.1 사용자 입력 처리",
          "description": "게임에서 키보드, 마우스, 게임패드 등을 통한 사용자 입력을 처리할 때, 각 입력을 Command 객체로 변환하여 유연하게 처리할 수 있습니다."
        },
        {
          "title": "3.2 히스토리 관리 시스템",
          "description": "사용자의 행동을 기록하고, 원하는 경우 이전 상태로 되돌리거나 재실행할 수 있는 기능이 필요한 경우에 적합합니다."
        },
        {
          "title": "3.3 AI 행동 시스템",
          "description": "NPC나 AI 에이전트의 행동을 Command 객체로 구현하여, 행동 계획이나 의사결정 시스템을 유연하게 구성할 수 있습니다."
        },
        {
          "title": "3.4 네트워크 게임 동기화",
          "description": "플레이어의 행동을 Command 객체로 직렬화하여 네트워크를 통해 전송하고, 다른 클라이언트에서 재생하는 방식으로 게임 상태를 동기화할 수 있습니다."
        }
      ]
    },
    {
      "id": "implementation",
      "title": "4. 어떻게 구현하는가?",
      "content": "Command 패턴의 구현은 다양한 언어로 가능합니다. 아래 링크를 통해 각 언어별 구현 코드를 확인할 수 있습니다.",
      "codeLinks": [
        {
          "language": "C#",
          "url": "codes/command_csharp.html"
        },
        {
          "language": "C++",
          "url": "codes/command_cpp.html"
        }
      ]
    },
    {
      "id": "pros-cons",
      "title": "5. Command 패턴의 장단점",
      "pros": [
        {
          "title": "단일 책임 원칙 준수",
          "description": "작업을 수행하는 클래스와 작업을 호출하는 클래스가 분리되어 있어, 각 클래스는 단일 책임을 갖습니다."
        },
        {
          "title": "개방/폐쇄 원칙 준수",
          "description": "기존 코드를 수정하지 않고도 새로운 명령을 추가할 수 있어 확장성이 뛰어납니다."
        },
        {
          "title": "작업의 취소/재실행 구현 용이",
          "description": "각 명령 객체가 자신의 실행 및 취소 로직을 포함하므로, 히스토리 기능을 쉽게 구현할 수 있습니다."
        },
        {
          "title": "복합 명령 생성 가능",
          "description": "여러 명령을 조합하여 복잡한 작업을 간단하게 만들 수 있습니다."
        }
      ],
      "cons": [
        {
          "title": "클래스 수 증가",
          "description": "각 작업마다 별도의 Command 클래스가 필요하므로, 클래스 수가 증가하여 코드 복잡성이 높아질 수 있습니다."
        },
        {
          "title": "메모리 사용량 증가",
          "description": "모든 명령 객체를 저장하는 히스토리 스택을 유지할 경우, 메모리 사용량이 증가할 수 있습니다."
        },
        {
          "title": "간단한 작업에는 오버헤드",
          "description": "단순한 작업의 경우, Command 패턴을 적용하면 불필요한 오버헤드가 발생할 수 있습니다."
        }
      ]
    },
    {
      "id": "best-practices",
      "title": "6. 주의사항 및 모범 사례",
      "practices": [
        {
          "title": "명령 객체의 크기 관리",
          "description": "히스토리 스택이 너무 커지지 않도록 최대 크기를 제한하거나, 주기적으로 오래된 명령을 정리하는 메커니즘을 구현하세요."
        },
        {
          "title": "상태 의존성 주의",
          "description": "명령 객체가 외부 상태에 너무 의존적이면 취소/재실행 기능이 예상대로 작동하지 않을 수 있습니다. 필요한 상태 정보를 명령 객체 내부에 저장하는 것이 좋습니다."
        },
        {
          "title": "성능 고려",
          "description": "많은 수의 작은 명령들을 처리해야 하는 경우, 명령 객체 풀링(Object Pooling)을 고려하여 메모리 할당 오버헤드를 줄이세요."
        },
        {
          "title": "명령 직렬화",
          "description": "네트워크 게임에서 Command 패턴을 사용할 경우, 명령 객체를 직렬화하여 네트워크를 통해 전송할 수 있도록 설계하는 것이 좋습니다."
        }
      ]
    }
  ],
  "navigation": {
    "back": {
      "url": "patterns.html",
      "text": "패턴 목록으로 돌아가기"
    },
    "next": {
      "url": "codes/command_csharp.html",
      "text": "C# 코드 예제 보기"
    }
  }
}