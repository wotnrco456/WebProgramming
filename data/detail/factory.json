{
  "id": "factory",
  "title": "Factory 패턴",
  "meta": {
    "category": "생성 패턴",
    "difficulty": "난이도: ★★☆☆☆"
  },
  "sections": [
    {
      "id": "overview",
      "title": "패턴 개요",
      "content": "Factory 패턴은 객체 생성 로직을 캡슐화하여 유연한 객체 생성이 가능하게 하는 디자인 패턴입니다. 이 패턴은 객체의 생성과 사용을 분리하여 코드의 유지보수성과 확장성을 높입니다.",
      "benefits": [
        "객체 생성 로직을 한 곳에서 관리하여 코드 중복을 방지",
        "새로운 타입의 객체 추가가 용이하여 확장성이 높음",
        "클라이언트 코드와 구체적인 클래스 간의 결합도 감소",
        "객체 생성 과정의 일관성 유지",
        "인터페이스에 맞춰 코딩하여 시스템의 변화에 유연하게 대응 가능"
      ],
      "useCases": [
        "게임 오브젝트 생성 (캐릭터, 아이템, 효과 등)",
        "UI 요소 생성",
        "레벨 디자인에서 다양한 오브젝트 생성",
        "리소스 로딩 및 관리",
        "다양한 타입의 무기나 아이템 생성"
      ]
    },
    {
      "id": "types",
      "title": "1. 팩토리 패턴의 종류",
      "subtypes": [
        {
          "title": "1.1 Simple Factory (간단한 팩토리)",
          "description": "가장 기본적인 형태의 팩토리 패턴으로, 객체 생성 로직을 하나의 클래스에 캡슐화합니다. 디자인 패턴이라기보다는 프로그래밍 관용구에 가깝습니다."
        },
        {
          "title": "1.2 Factory Method (팩토리 메소드)",
          "description": "객체를 생성하기 위한 인터페이스를 정의하고, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정하게 만듭니다. 클래스의 인스턴스를 만드는 일을 서브클래스에게 맡기는 패턴입니다."
        },
        {
          "title": "1.3 Abstract Factory (추상 팩토리)",
          "description": "인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체들을 구상 클래스를 지정하지 않고도 생성할 수 있게 합니다. 제품군을 생성하기 위한 인터페이스를 제공합니다."
        }
      ]
    },
    {
      "id": "why",
      "title": "2. 왜 팩토리 패턴을 사용해야 하는가?",
      "benefits": [
        {
          "title": "2.1 객체 생성의 유연성",
          "description": "객체 생성 로직을 한 곳에서 관리하여 코드의 중복을 방지하고, 새로운 타입의 객체 추가가 용이해집니다."
        },
        {
          "title": "2.2 결합도 감소",
          "description": "클라이언트 코드가 구체적인 클래스에 직접 의존하지 않아 코드의 결합도가 낮아지고 유지보수성이 향상됩니다."
        },
        {
          "title": "2.3 확장성 향상",
          "description": "새로운 제품 타입을 추가할 때 기존 코드를 수정하지 않고도 확장이 가능합니다."
        },
        {
          "title": "2.4 일관성 유지",
          "description": "객체 생성 과정을 표준화하여 일관된 방식으로 객체를 생성할 수 있습니다."
        }
      ]
    },
    {
      "id": "when",
      "title": "3. 어떤 상황에서 사용해야 하는가?",
      "useCases": [
        {
          "title": "3.1 객체 생성이 복잡한 경우",
          "description": "객체 생성에 여러 단계나 조건이 필요한 경우, 이 로직을 팩토리 클래스에 캡슐화하여 관리합니다."
        },
        {
          "title": "3.2 런타임에 객체 타입이 결정되는 경우",
          "description": "프로그램 실행 중에 어떤 타입의 객체를 생성할지 결정해야 하는 경우에 적합합니다."
        },
        {
          "title": "3.3 객체 생성에 의존성이 있는 경우",
          "description": "객체 생성 시 다른 객체나 설정이 필요한 경우, 팩토리에서 이러한 의존성을 관리합니다."
        },
        {
          "title": "3.4 객체 풀링이 필요한 경우",
          "description": "객체를 재사용해야 하는 경우, 팩토리에서 객체 풀을 관리할 수 있습니다."
        }
      ]
    },
    {
      "id": "implementation",
      "title": "4. 어떻게 구현하는가?",
      "content": "Factory 패턴의 구현은 다양한 언어로 가능합니다. 아래 링크를 통해 각 언어별 구현 코드를 확인할 수 있습니다.",
      "codeLinks": [
        {
          "language": "C#",
          "url": "codes/factory_csharp.html"
        },
        {
          "language": "C++",
          "url": "codes/factory_cpp.html"
        }
      ]
    },
    {
      "id": "pros-cons",
      "title": "5. 팩토리 패턴의 장단점",
      "pros": [
        {
          "title": "객체 생성 로직을 한 곳에서 관리하여 코드 중복 방지",
          "description": "객체 생성과 관련된 모든 로직이 팩토리 클래스에 집중되어 있어 코드의 중복을 방지하고 유지보수가 용이합니다."
        },
        {
          "title": "새로운 제품 타입 추가가 용이",
          "description": "새로운 제품 타입을 추가할 때 기존 코드를 수정하지 않고도 확장이 가능합니다."
        },
        {
          "title": "클라이언트 코드와 구체적인 클래스 간의 결합도 감소",
          "description": "클라이언트는 구체적인 클래스가 아닌 인터페이스에 의존하게 되어 결합도가 낮아집니다."
        },
        {
          "title": "객체 생성 과정의 일관성 유지",
          "description": "모든 객체가 동일한 방식으로 생성되므로 일관성이 보장됩니다."
        }
      ],
      "cons": [
        {
          "title": "클래스 수가 증가하여 코드가 복잡해질 수 있음",
          "description": "팩토리 패턴을 적용하면 인터페이스, 구체 클래스, 팩토리 클래스 등 여러 클래스가 추가되어 코드가 복잡해질 수 있습니다."
        },
        {
          "title": "간단한 객체 생성의 경우 오버엔지니어링이 될 수 있음",
          "description": "단순한 객체 생성의 경우 팩토리 패턴을 적용하는 것이 불필요한 복잡성을 추가할 수 있습니다."
        },
        {
          "title": "팩토리 클래스가 모든 제품 타입을 알아야 함",
          "description": "새로운 제품 타입이 추가될 때마다 팩토리 클래스도 수정해야 하는 경우가 발생할 수 있습니다."
        }
      ]
    },
    {
      "id": "best-practices",
      "title": "6. 주의사항 및 모범 사례",
      "practices": [
        {
          "title": "적절한 추상화 수준 선택",
          "description": "팩토리 패턴을 적용할 때는 적절한 추상화 수준을 선택하는 것이 중요합니다. 너무 세분화하면 코드가 복잡해지고, 너무 일반화하면 유연성이 떨어질 수 있습니다."
        },
        {
          "title": "팩토리 메서드와 추상 팩토리 패턴 구분",
          "description": "팩토리 메서드는 단일 객체 생성에 집중하고, 추상 팩토리는 관련된 객체 그룹을 생성하는 데 사용됩니다. 상황에 맞는 패턴을 선택하세요."
        },
        {
          "title": "명확한 제품 인터페이스 설계",
          "description": "제품 클래스들이 공유하는 인터페이스를 명확하게 설계하여 클라이언트 코드가 구체적인 클래스에 의존하지 않도록 합니다."
        },
        {
          "title": "매개변수화된 팩토리 메서드 고려",
          "description": "다양한 종류의 제품을 생성해야 하는 경우, 팩토리 메서드에 매개변수를 전달하여 생성할 제품을 결정하는 방식을 고려할 수 있습니다."
        },
        {
          "title": "객체 재사용과 풀링 고려",
          "description": "게임에서 자주 생성되고 파괴되는 객체(총알, 파티클 등)의 경우, 팩토리 패턴과 객체 풀 패턴을 결합하여 성능을 최적화할 수 있습니다."
        }
      ]
    }
  ],
  "navigation": {
    "back": {
      "url": "patterns.html",
      "text": "패턴 목록으로 돌아가기"
    },
    "next": {
      "url": "codes/factory_csharp.html",
      "text": "C# 코드 예제 보기"
    }
  }
}