{
  "id": "strategy",
  "title": "Strategy 패턴",
  "meta": {
    "category": "행동 패턴",
    "difficulty": "난이도: ★★★☆☆"
  },
  "sections": [
    {
      "id": "overview",
      "title": "패턴 개요",
      "content": "Strategy 패턴은 알고리즘 군을 정의하고, 각각을 캡슐화하여 상호 교환 가능하게 만드는 디자인 패턴입니다. 이 패턴을 사용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있으며, 런타임에 알고리즘을 교체할 수 있습니다.",
      "benefits": [
        "알고리즘을 쉽게 교체할 수 있는 유연성 제공",
        "조건문을 줄여 코드 가독성 향상",
        "새로운 전략 추가가 용이하여 확장성이 높음",
        "각 알고리즘을 캡슐화하여 재사용성 증가",
        "책임의 분리를 통한 유지보수성 향상"
      ],
      "useCases": [
        "게임 캐릭터의 다양한 공격 방식 구현",
        "AI 행동 패턴 정의 및 전환",
        "게임 난이도에 따른 다양한 동작 방식 구현",
        "이동, 점프, 회피 등 다양한 캐릭터 능력 구현",
        "경로 탐색이나 의사 결정 알고리즘 전환"
      ]
    },
    {
      "id": "basic-concept",
      "title": "1. Strategy 패턴의 기본 개념",
      "subtypes": [
        {
          "title": "1.1 패턴 구성 요소",
          "description": "Strategy (전략) 인터페이스: 모든 구체적인 전략이 구현해야 하는 공통 인터페이스를 정의합니다. ConcreteStrategy (구체적인 전략): Strategy 인터페이스를 구현하는 다양한 알고리즘 클래스들입니다. Context (컨텍스트): Strategy 객체를 참조하고 사용하는 클래스입니다. 런타임에 다른 전략으로 교체할 수 있는 메서드를 제공합니다."
        },
        {
          "title": "1.2 패턴 작동 방식",
          "description": "컨텍스트 객체는 전략 객체의 레퍼런스를 유지하며, 실제 작업을 처리할 때 해당 전략 객체에게 작업을 위임합니다. 클라이언트는 원하는 전략을 선택하고 컨텍스트에 설정할 수 있으며, 런타임에 전략을 변경할 수 있습니다."
        }
      ]
    },
    {
      "id": "why",
      "title": "2. 왜 Strategy 패턴을 사용해야 하는가?",
      "benefits": [
        {
          "title": "2.1 유연한 알고리즘 교체",
          "description": "조건문이나 상속 대신 전략 객체를 교체하는 방식으로 런타임에 동작을 변경할 수 있어 코드의 유연성이 향상됩니다."
        },
        {
          "title": "2.2 조건문 제거",
          "description": "여러 조건에 따라 다른 알고리즘을 사용하는 복잡한 조건문을 제거하고, 각 알고리즘을 개별 클래스로 캡슐화하여 코드의 명확성이 높아집니다."
        },
        {
          "title": "2.3 Open/Closed 원칙 준수",
          "description": "새로운 전략을 추가할 때 기존 코드를 수정하지 않고도 확장할 수 있어 Open/Closed 원칙을 준수합니다."
        },
        {
          "title": "2.4 재사용성 향상",
          "description": "각 알고리즘이 독립적인 클래스로 캡슐화되어 있어 다른 컨텍스트에서도 재사용이 가능합니다."
        }
      ]
    },
    {
      "id": "when",
      "title": "3. 어떤 상황에서 사용해야 하는가?",
      "useCases": [
        {
          "title": "3.1 다양한 알고리즘 변형이 필요한 경우",
          "description": "게임에서 AI 캐릭터의 다양한 행동 패턴, 다른 타입의 무기, 다양한 이동 방식 등 여러 알고리즘 변형이 필요할 때 적합합니다."
        },
        {
          "title": "3.2 런타임에 동작 교체가 필요한 경우",
          "description": "게임 진행 중 캐릭터의 능력이 변하거나, 상황에 따라 다른 전략을 사용해야 할 때 유용합니다."
        },
        {
          "title": "3.3 조건문이 복잡해지는 경우",
          "description": "동작 방식을 결정하는 조건문이 너무 복잡해질 때, 전략 패턴을 사용하여 각 동작을 개별 클래스로 분리하면 코드가 간결해집니다."
        },
        {
          "title": "3.4 클래스 상속으로 인한 문제가 발생할 경우",
          "description": "상속을 통해 여러 알고리즘을 처리하려고 할 때 클래스 계층 구조가 복잡해지는 경우, 전략 패턴을 사용하여 구성(Composition)으로 문제를 해결할 수 있습니다."
        }
      ]
    },
    {
      "id": "implementation",
      "title": "4. 어떻게 구현하는가?",
      "content": "Strategy 패턴의 구현은 다양한 언어로 가능합니다. 아래 링크를 통해 각 언어별 구현 코드를 확인할 수 있습니다.",
      "codeLinks": [
        {
          "language": "C#",
          "url": "codes/strategy_csharp.html"
        },
        {
          "language": "C++",
          "url": "codes/strategy_cpp.html"
        }
      ]
    },
    {
      "id": "pros-cons",
      "title": "5. Strategy 패턴의 장단점",
      "pros": [
        {
          "title": "런타임에 알고리즘 교체 가능",
          "description": "실행 중에 객체의 동작을 변경할 수 있어 유연한 시스템 구축이 가능합니다."
        },
        {
          "title": "알고리즘의 분리 및 캡슐화",
          "description": "각 알고리즘이 독립적인 클래스로 캡슐화되어 있어 관리와 확장이 용이합니다."
        },
        {
          "title": "조건문 제거",
          "description": "복잡한 조건문을 전략 객체로 대체하여 코드의 가독성과 유지보수성이 향상됩니다."
        },
        {
          "title": "확장성 향상",
          "description": "새로운 전략을 추가할 때 기존 코드를 수정하지 않고도 새로운 클래스만 추가하면 됩니다."
        }
      ],
      "cons": [
        {
          "title": "클래스 수 증가",
          "description": "각 알고리즘마다 별도의 클래스가 필요하므로 전체 클래스 수가 증가할 수 있습니다."
        },
        {
          "title": "클라이언트의 복잡성",
          "description": "클라이언트가 다양한 전략을 인식하고 선택해야 하므로 클라이언트의 복잡성이 증가할 수 있습니다."
        },
        {
          "title": "오버헤드 발생",
          "description": "전략 객체 생성과 관리에 따른 추가적인 오버헤드가 발생할 수 있습니다."
        },
        {
          "title": "컨텍스트와 전략 간의 의사소통",
          "description": "컨텍스트가 전략에 필요한 데이터를 전달하는 방식에 따라 추가적인 복잡성이 발생할 수 있습니다."
        }
      ]
    },
    {
      "id": "best-practices",
      "title": "6. 주의사항 및 모범 사례",
      "practices": [
        {
          "title": "전략 생성 및 관리",
          "description": "전략 객체의 생성과 관리를 위해 Factory 패턴이나 Dependency Injection을 고려하세요."
        },
        {
          "title": "기본 전략 설정",
          "description": "컨텍스트에 기본 전략을 설정하여 전략이 없는 상태를 방지하세요."
        },
        {
          "title": "전략 인터페이스 설계",
          "description": "전략 인터페이스는 간결하게 유지하고, 필요한 메서드만 포함하도록 설계하세요."
        },
        {
          "title": "전략 재사용",
          "description": "전략 객체가 상태를 유지하지 않는 경우, 싱글톤으로 구현하거나 객체 풀을 사용하여 메모리를 절약할 수 있습니다."
        }
      ]
    }
  ],
  "navigation": {
    "back": {
      "url": "patterns.html",
      "text": "패턴 목록으로 돌아가기"
    },
    "next": {
      "url": "codes/strategy_csharp.html",
      "text": "C# 코드 예제 보기"
    }
  }
}