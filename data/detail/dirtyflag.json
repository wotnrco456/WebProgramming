{
  "id": "dirtyflag",
  "title": "Dirty Flag 패턴",
  "meta": {
    "category": "행동 패턴",
    "difficulty": "난이도: ★★☆☆☆"
  },
  "sections": [
    {
      "id": "overview",
      "title": "패턴 개요",
      "content": "Dirty Flag 패턴은 객체의 상태가 변경되었을 때 이를 표시하고, 필요한 경우에만 업데이트 연산을 수행하도록 하는 최적화 패턴입니다. 게임 개발에서는 리소스 집약적인 계산이나 렌더링 작업을 최소화하기 위해 널리 사용됩니다.",
      "benefits": [
        "불필요한 연산 방지로 성능 향상",
        "연산이 필요한 객체만 선택적으로 업데이트",
        "복잡한 시스템에서 상태 변경 추적 용이",
        "메모리나 CPU 집약적인 연산의 최적화"
      ],
      "useCases": [
        "게임 월드의 동적 로딩 및 언로딩",
        "물리 시뮬레이션에서 변경된 객체만 업데이트",
        "GUI 시스템에서 변경된 요소만 다시 그리기",
        "게임 상태 저장 시 변경된 데이터만 저장",
        "네트워크 동기화에서 변경된 데이터만 전송"
      ]
    },
    {
      "id": "basic-concept",
      "title": "1. Dirty Flag 패턴의 기본 개념",
      "content": "Dirty Flag 패턴의 핵심은 다음과 같습니다:",
      "benefits": [
        "객체의 상태가 변경되었을 때 'dirty' 플래그를 설정",
        "필요한 시점에 dirty 플래그가 설정된 객체만 업데이트 수행",
        "업데이트 후 dirty 플래그를 초기화(clean)",
        "변경되지 않은 객체에 대한 불필요한 처리 회피"
      ]
    },
    {
      "id": "why",
      "title": "2. 왜 Dirty Flag 패턴을 사용해야 하는가?",
      "benefits": [
        {
          "title": "2.1 성능 최적화",
          "description": "게임에서는 많은 객체들이 매 프레임마다 업데이트되어야 합니다. Dirty Flag 패턴을 사용하면 변경된 객체만 선택적으로 업데이트하여 CPU와 메모리 리소스를 절약할 수 있습니다."
        },
        {
          "title": "2.2 효율적인 리소스 관리",
          "description": "특히 리소스 집약적인 작업(예: 텍스처 업데이트, 경로 계산, 물리 시뮬레이션)에서 모든 객체를 매번 업데이트하는 것은 비효율적입니다. Dirty Flag를 사용하면 필요한 객체만 업데이트할 수 있습니다."
        },
        {
          "title": "2.3 상태 변경 추적",
          "description": "복잡한 게임 시스템에서 어떤 객체의 상태가 변경되었는지 추적하기 어려울 수 있습니다. Dirty Flag는 상태 변경을 명시적으로 표시하여 추적을 용이하게 합니다."
        }
      ]
    },
    {
      "id": "when",
      "title": "3. 어떤 상황에서 사용해야 하는가?",
      "useCases": [
        {
          "title": "3.1 동적 레벨 로딩",
          "description": "플레이어 주변의 게임 월드 섹터만 로드하고 다른 부분은 언로드하여 메모리 사용을 최적화할 때 유용합니다."
        },
        {
          "title": "3.2 렌더링 최적화",
          "description": "변경된 객체나 화면의 특정 부분만 다시 렌더링하여 GPU 사용을 최소화할 수 있습니다."
        },
        {
          "title": "3.3 물리 시뮬레이션",
          "description": "움직이거나 상호작용하는 객체만 물리 계산을 수행하고 정적인 객체는 건너뛰어 성능을 향상시킵니다."
        },
        {
          "title": "3.4 네트워크 동기화",
          "description": "멀티플레이어 게임에서 변경된 데이터만 네트워크로 전송하여 대역폭 사용을 최적화합니다."
        }
      ]
    },
    {
      "id": "implementation",
      "title": "4. 어떻게 구현하는가?",
      "content": "Dirty Flag 패턴의 구현은 다양한 언어로 가능합니다. 아래 링크를 통해 각 언어별 구현 코드를 확인할 수 있습니다.",
      "codeLinks": [
        {
          "language": "C#",
          "url": "codes/dirtyflag_csharp.html"
        },
        {
          "language": "C++",
          "url": "codes/dirtyflag_cpp.html"
        }
      ]
    },
    {
      "id": "pros-cons",
      "title": "5. Dirty Flag 패턴의 장단점",
      "pros": [
        {
          "title": "성능 향상",
          "description": "필요한 객체만 선택적으로 업데이트하여 CPU와 메모리 사용을 최적화합니다."
        },
        {
          "title": "리소스 효율성",
          "description": "변경되지 않은 객체에 대한 불필요한 처리를 방지하여 리소스를 절약합니다."
        },
        {
          "title": "명확한 상태 관리",
          "description": "객체의 상태 변경을 명시적으로 표시하여 코드의 가독성과 관리성을 향상시킵니다."
        }
      ],
      "cons": [
        {
          "title": "추가적인 상태 관리",
          "description": "dirty 플래그를 관리하기 위한 추가 코드가 필요하며, 이로 인해 코드 복잡성이 증가할 수 있습니다."
        },
        {
          "title": "플래그 관리 오류",
          "description": "플래그를 적절히 설정하거나 초기화하지 않으면 업데이트가 누락되거나 불필요한 업데이트가 발생할 수 있습니다."
        },
        {
          "title": "디버깅 어려움",
          "description": "상태 변경 추적이 복잡해질 수 있어 디버깅이 어려워질 수 있습니다."
        }
      ]
    },
    {
      "id": "best-practices",
      "title": "6. 주의사항 및 모범 사례",
      "practices": [
        {
          "title": "명확한 책임 할당",
          "description": "객체가 자신의 dirty 플래그를 설정하고 다른 객체가 이를 확인하고 업데이트하는 책임을 명확히 구분하세요."
        },
        {
          "title": "상태 변경 일관성",
          "description": "상태가 변경될 때마다 항상 dirty 플래그를 설정하도록 일관된 규칙을 유지하세요."
        },
        {
          "title": "필요한 곳에만 적용",
          "description": "모든 객체에 Dirty Flag를 적용하면 오히려 오버헤드가 발생할 수 있습니다. 업데이트 비용이 큰 객체에 선택적으로 적용하세요."
        },
        {
          "title": "의존성 고려",
          "description": "객체 간 의존성이 있는 경우, 한 객체의 변경이 다른 객체에도 영향을 미칠 수 있으므로 이를 고려한 설계가 필요합니다."
        }
      ]
    }
  ],
  "navigation": {
    "back": {
      "url": "patterns.html",
      "text": "패턴 목록으로 돌아가기"
    },
    "next": {
      "url": "codes/dirtyflag_csharp.html",
      "text": "C# 코드 예제 보기"
    }
  }
}